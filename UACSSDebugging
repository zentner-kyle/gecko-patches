# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  6f540df4167c17dacbe6455cfd72aff2d1990d44

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -660,33 +660,58 @@ nsBlockFrame::CheckIntrinsicCacheAgainst
     if (inflationEnabled) {
       AddStateBits(NS_BLOCK_FRAME_INTRINSICS_INFLATED);
     } else {
       RemoveStateBits(NS_BLOCK_FRAME_INTRINSICS_INFLATED);
     }
   }
 }
 
+nsIFrame*
+nsBlockFrame::GetRoot()
+{
+  nsIFrame* f = this;
+  while (f->GetParent()) {
+    f = f->GetParent();
+  }
+  return f;
+}
+
 /* virtual */ nscoord
 nsBlockFrame::GetMinISize(nsRenderingContext *aRenderingContext)
 {
   nsIFrame* firstInFlow = FirstContinuation();
   if (firstInFlow != this)
     return firstInFlow->GetMinISize(aRenderingContext);
 
   DISPLAY_MIN_WIDTH(this, mMinWidth);
 
   CheckIntrinsicCacheAgainstShrinkWrapState();
 
+  static bool dumped = false;
   if (StyleDisplay()->IsContainLayout()) {
+    printf("CONTAIN LAYOUT in GetMinISize\n");
     if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN) {
       return mMinWidth;
     } else {
       return 0;
     }
+  } else {
+    if (!dumped) {
+      dumped = true;
+      nsIPresShell* presShell = PresContext()->GetPresShell(); 
+      presShell->GetRootFrame()->List();
+      presShell->ListStyleContexts(presShell->GetRootFrame(), stdout);
+      presShell->ListStyleSheets(stdout);
+
+      printf("\n\nTHIS FRAME ONLY:\n\n");
+      List();
+      presShell->ListStyleContexts(this, stdout);
+      printf("\n\n");
+    }
   }
 
   if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
     return mMinWidth;
 
 #ifdef DEBUG
   if (gNoisyIntrinsic) {
     IndentBy(stdout, gNoiseIndent);
@@ -765,16 +790,17 @@ nsBlockFrame::GetPrefISize(nsRenderingCo
   if (firstInFlow != this)
     return firstInFlow->GetPrefISize(aRenderingContext);
 
   DISPLAY_PREF_WIDTH(this, mPrefWidth);
 
   CheckIntrinsicCacheAgainstShrinkWrapState();
 
   if (StyleDisplay()->IsContainLayout()) {
+    printf("CONTAIN LAYOUT in GetPrefISize\n");
     if (mPrefWidth != NS_INTRINSIC_WIDTH_UNKNOWN) {
       return mPrefWidth;
     } else {
       return 0;
     }
   }
 
 
@@ -1511,16 +1537,19 @@ nsBlockFrame::ComputeFinalSize(const nsH
       aState.mPrevBEndMargin.Zero();
     }
     aMetrics.mCarriedOutBEndMargin = aState.mPrevBEndMargin;
   } else {
     aMetrics.mCarriedOutBEndMargin.Zero();
   }
 
   nscoord blockEndEdgeOfChildren = aState.mBCoord + nonCarriedOutBDirMargin;
+  if (StyleDisplay()->IsContainLayout()) {
+    printf("CONTAIN LAYOUT in ComputeFinalSize\n");
+  }
   if (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedBSize() &&
       StyleDisplay()->IsContainLayout()) {
     blockEndEdgeOfChildren = 0;
   }
   // Shrink wrap our height around our contents.
   if (aState.GetFlag(BRS_ISBENDMARGINROOT) ||
       NS_UNCONSTRAINEDSIZE != aReflowState.ComputedBSize()) {
     // When we are a block-end-margin root make sure that our last
@@ -1540,16 +1569,18 @@ nsBlockFrame::ComputeFinalSize(const nsH
   if (aState.GetFlag(BRS_FLOAT_MGR)) {
     // Include the float manager's state to properly account for the
     // block-end margin of any floated elements; e.g., inside a table cell.
     nscoord floatHeight =
       aState.ClearFloats(blockEndEdgeOfChildren, NS_STYLE_CLEAR_BOTH,
                          nullptr, nsFloatManager::DONT_CLEAR_PUSHED_FLOATS);
     if (!StyleDisplay()->IsContainLayout()) {
       blockEndEdgeOfChildren = std::max(blockEndEdgeOfChildren, floatHeight);
+    } else {
+      printf("CONTAIN LAYOUT in ComputeFinalSize\n");
     }
   }
 
   if (NS_UNCONSTRAINEDSIZE != aReflowState.ComputedBSize()
       && (GetParent()->GetType() != nsGkAtoms::columnSetFrame ||
           aReflowState.parentReflowState->AvailableBSize() == NS_UNCONSTRAINEDSIZE)) {
     ComputeFinalBSize(aReflowState, &aState.mReflowStatus,
                       aState.mBCoord + nonCarriedOutBDirMargin,
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -137,16 +137,17 @@ public:
   }
 
   virtual void InvalidateFrame(uint32_t aDisplayItemKey = 0) override;
   virtual void InvalidateFrameWithRect(const nsRect& aRect, uint32_t aDisplayItemKey = 0) override;
 
 #ifdef DEBUG_FRAME_DUMP
   void List(FILE* out = stderr, const char* aPrefix = "", uint32_t aFlags = 0) const override;
   virtual nsresult GetFrameName(nsAString& aResult) const override;
+  nsIFrame* GetRoot();
 #endif
 
 #ifdef DEBUG
   virtual nsFrameState GetDebugStateBits() const override;
 #endif
 
 #ifdef ACCESSIBILITY
   virtual mozilla::a11y::AccType AccessibleType() override;
diff --git a/layout/reftests/w3c-css/submitted/contain/contain-layout-inline-block-003.html b/layout/reftests/w3c-css/submitted/contain/contain-layout-inline-block-003.html
--- a/layout/reftests/w3c-css/submitted/contain/contain-layout-inline-block-003.html
+++ b/layout/reftests/w3c-css/submitted/contain/contain-layout-inline-block-003.html
@@ -8,17 +8,17 @@
   <link rel="help" href="http://www.w3.org/TR/css-containment-1/#containment-layout">
   <link rel="match" href="contain-layout-inline-block-003-ref.html">
   <style>
   body {
     margin: 0;
   }
   .container {
     display: inline-block;
-    contain: layout;
+    contain: layout !important;
     overflow: hidden;
     background: red;
     border: 8px solid green;
     margin: 2px;
   }
 
   .right-float {
     float: right;
@@ -61,16 +61,20 @@
 <body>
   <!--
     Since the contents of a contained element do not move the baseline, all
     of the following green boxes should be on the same line, and the same size.
     All of the words should be on the same line as each other as well.
   -->
   <div class="container"></div>
   Word
+  <script>
+    var c = document.getElementsByClassName('container')[0];
+    document.write(getComputedStyle(c).contain);
+  </script>
   <div class="container">Test text contents.</div>
   Word
   <div class="container"><div><div class="right-float"></div></div></div>
   Word
   <div class="container"><div><div class="left-float"></div></div></div>
   Word
   <div class="container"><div class="block"></div></div>
   Word
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -153,17 +153,18 @@
 }
 
 *|*::-moz-scrolled-content, *|*::-moz-scrolled-canvas,
 *|*::-moz-scrolled-page-sequence {
   /* e.g., text inputs, select boxes */
   padding: inherit;
   /* The display doesn't affect the kind of frame constructed here.  This just
      affects auto-width sizing of the block we create. */
-  contain: inherit;
+  contain: layout !important;
+  background: green;
   display: block;
   -moz-box-orient: inherit;
   /* make unicode-bidi inherit, otherwise it has no effect on text inputs and
      blocks with overflow: scroll; */
   unicode-bidi: inherit;
   text-overflow: inherit;
   -moz-column-count: inherit;
   -moz-column-width: inherit;
diff --git a/layout/tools/reftest/reftest-preferences.js b/layout/tools/reftest/reftest-preferences.js
--- a/layout/tools/reftest/reftest-preferences.js
+++ b/layout/tools/reftest/reftest-preferences.js
@@ -1,8 +1,9 @@
+if (false) {
     // For mochitests, we're more interested in testing the behavior of in-
     // content XBL bindings, so we set this pref to true. In reftests, we're
     // more interested in testing the behavior of XBL as it works in chrome,
     // so we want this pref to be false.
     branch.setBoolPref("dom.use_xbl_scopes_for_remote_xul", false);
     branch.setIntPref("gfx.color_management.mode", 2);
     branch.setBoolPref("gfx.color_management.force_srgb", true);
     branch.setBoolPref("browser.dom.window.dump.enabled", true);
@@ -65,8 +66,9 @@
     // Make sure SelfSupport doesn't hit the network.
     branch.setCharPref("browser.selfsupport.url", "https://%(server)s/selfsupport-dummy/");
 
     // Disable periodic updates of service workers.
     branch.setBoolPref("dom.serviceWorkers.periodic-updates.enabled", false);
 
     // Allow XUL and XBL files to be opened from file:// URIs
     branch.setBoolPref("dom.allow_XUL_XBL_for_file", true);
+}
