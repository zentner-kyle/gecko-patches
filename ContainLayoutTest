# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  18f29c7f7d7a69f3fba032a99fa582ef81a46225

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -3939,19 +3939,16 @@ nsCSSFrameConstructor::ConstructFrameFro
       }
 
       // Set the frame's initial child list
       // Note that MathML depends on this being called even if
       // childItems is empty!
       newFrameAsContainer->SetInitialChildList(kPrincipalList, childItems);
     }
   }
-  if (container) {
-    AddContainedChildren(aState, content, container, containedItems);
-  }
 
 #ifdef MOZ_XUL
   // More icky XUL stuff
   if (aItem.mNameSpaceID == kNameSpaceID_XUL &&
       (aItem.mTag == nsGkAtoms::treechildren || // trees always need titletips
        content->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltiptext) ||
        content->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltip))) {
     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
@@ -3972,19 +3969,24 @@ nsCSSFrameConstructor::ConstructFrameFro
   // Even if mCreatingExtraFrames is set, we may need to SetPrimaryFrame for
   // generated content that doesn't have one yet.  Note that we have to examine
   // the frame bit, because by this point mIsGeneratedContent has been cleared
   // on aItem.
   if ((!aState.mCreatingExtraFrames ||
        ((primaryFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) &&
         !aItem.mContent->GetPrimaryFrame())) &&
        !(bits & FCDATA_SKIP_FRAMESET)) {
+       //&&
+       //!container) {
     aItem.mContent->SetPrimaryFrame(primaryFrame);
     ActiveLayerTracker::TransferActivityToFrame(aItem.mContent, primaryFrame);
   }
+  if (container) {
+    AddContainedChildren(aState, content, container, containedItems);
+  }
 }
 
 // after the node has been constructed and initialized create any
 // anonymous content a node needs.
 nsresult
 nsCSSFrameConstructor::CreateAnonymousFrames(nsFrameConstructorState& aState,
                                              nsIContent*              aParent,
                                              nsContainerFrame*        aParentFrame,
@@ -4467,32 +4469,34 @@ nsCSSFrameConstructor::BuildContainment(
                                         nsContainerFrame*        aParentFrame,
                                         nsFrameItems            &aParentItems)
 {
   nsRefPtr<nsStyleContext> containerStyle =
     mPresShell->StyleSet()->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::containment,
                                                      aContentStyle);
 
   nsContainerFrame *container = new (mPresShell) nsContainmentFrame(containerStyle);
+  //containerStyle->StyleDisplay()->mDisplay = aContentStyle->StyleDisplay()->mDisplay;
   //nsContainerFrame *container = NS_NewBlockFrame(mPresShell, containerStyle);
   InitAndRestoreFrame(aState, aContent, aParentFrame, container);
   aState.AddChild(container, aParentItems, aContent, aContentStyle,
                   aParentFrame, true, true, false);
 
   return container;
 }
 
 void
 nsCSSFrameConstructor::AddContainedChildren(nsFrameConstructorState& aState,
                                             nsIContent*              aContent,
                                             nsContainerFrame*        aContainer,
                                             nsFrameItems            &aContained)
 {
   CreateAnonymousFrames(aState, aContent, aContainer, nullptr, aContained);
   aContainer->SetInitialChildList(kPrincipalList, aContained);
+  //aContent->SetPrimaryFrame(aContainer);
 }
 
 void
 nsCSSFrameConstructor::FinishBuildingScrollFrame(nsContainerFrame* aScrollFrame,
                                                  nsIFrame* aScrolledFrame)
 {
   nsFrameList scrolled(aScrolledFrame, aScrolledFrame);
   aScrollFrame->AppendFrames(kPrincipalList, scrolled);
@@ -8028,29 +8032,32 @@ nsCSSFrameConstructor::ContentRemoved(ns
     if (gReallyNoisyContentUpdates) {
       aContainer->List(stdout, 0);
     }
   }
 #endif
 
   nsresult rv = NS_OK;
   nsIFrame* childFrame = aChild->GetPrimaryFrame();
+  while (childFrame && childFrame->StyleDisplay()->IsLayoutContaining()) {
+    childFrame = childFrame->GetParent();
+  }
   if (!childFrame || childFrame->GetContent() != aChild) {
     // XXXbz the GetContent() != aChild check is needed due to bug 135040.
     // Remove it once that's fixed.
     ClearUndisplayedContentIn(aChild, aContainer);
   }
   MOZ_ASSERT(!childFrame || !GetDisplayContentsStyleFor(aChild),
              "display:contents nodes shouldn't have a frame");
   if (!childFrame && GetDisplayContentsStyleFor(aChild)) {
     nsIFrame* ancestorFrame = nullptr;
     nsIContent* ancestor = aContainer;
     for (; ancestor; ancestor = ancestor->GetParent()) {
       ancestorFrame = ancestor->GetPrimaryFrame();
-      if (ancestorFrame) {
+      if (ancestorFrame && !ancestorFrame->StyleDisplay()->IsLayoutContaining()) {
         break;
       }
     }
     if (ancestorFrame) {
       nsTArray<nsIContent*>* generated = ancestorFrame->GetGenConPseudos();
       if (generated) {
         *aDidReconstruct = true;
         LAYOUT_PHASE_TEMP_EXIT();
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5130,16 +5130,18 @@ nsBlockFrame::AddFrames(nsFrameList& aFr
     NS_ASSERTION(!aPrevSibling || aPrevSibling->GetNextSibling() == newFrame,
                  "Unexpected aPrevSibling");
     NS_ASSERTION(newFrame->GetType() != nsGkAtoms::placeholderFrame ||
                  (!newFrame->IsAbsolutelyPositioned() &&
                   !newFrame->IsFloating()),
                  "Placeholders should not float or be positioned");
 
     bool isBlock = newFrame->IsBlockOutside();
+    //newFrame->List(stdout);
+    //printf("isBlock = %d\n", isBlock);
 
     // If the frame is a block frame, or if there is no previous line or if the
     // previous line is a block line we need to make a new line.  We also make
     // a new line, as an optimization, in the two cases we know we'll need it:
     // if the previous line ended with a <br>, or if it has significant whitespace
     // and ended in a newline.
     if (isBlock || prevSibLine == lineList->end() || prevSibLine->IsBlock() ||
         (aPrevSibling && ShouldPutNextSiblingOnNewLine(aPrevSibling))) {
diff --git a/layout/generic/nsContainmentFrame.cpp b/layout/generic/nsContainmentFrame.cpp
--- a/layout/generic/nsContainmentFrame.cpp
+++ b/layout/generic/nsContainmentFrame.cpp
@@ -4,19 +4,16 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 
 #include "nsContainmentFrame.h"
 
 #include "nsFrameManager.h"
 #include "nsLayoutUtils.h"
 #include "mozilla/AutoRestore.h"
-//#include "nsBlockReflowState.h"
-//#include "nsContainerFrame.h"
-
 
 NS_IMPL_FRAMEARENA_HELPERS(nsContainmentFrame)
 
 #ifdef DEBUG
 NS_QUERYFRAME_HEAD(nsContainmentFrame)
   NS_QUERYFRAME_ENTRY(nsContainmentFrame)
 NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)
 #endif
@@ -34,270 +31,70 @@ nsContainmentFrame::Reflow(nsPresContext
   nsIFrame* child = mFrames.FirstChild();
   MOZ_ASSERT(child && !mFrames.FirstChild()->GetNextSibling(),
              "nsContainmentFrame should have exactly one child");
 
   nsHTMLReflowMetrics childDesiredSize(aReflowState);
 
   WritingMode wm = aReflowState.GetWritingMode();
   nscoord iSize = aReflowState.AvailableISize();
-  //if (child->IsInline()) {
-    //iSize = NS_UNCONSTRAINEDSIZE;
-  //}
   LogicalSize availSize(wm, iSize, NS_UNCONSTRAINEDSIZE);
 
   nsHTMLReflowState childReflowState(aPresContext, aReflowState,
                                      child, availSize);
 
   // The child should act as though it has no contents.
   if (childReflowState.ComputedBSize() == NS_UNCONSTRAINEDSIZE) {
     childReflowState.SetComputedBSize(0);
   }
 
-  // offsets of wrapper frame
-  //NS_ASSERTION(aReflowState.ComputedLogicalBorderPadding().IStart() == 0 &&
-               //aReflowState.ComputedLogicalBorderPadding().BStart() == 0,
-               //"nsContainmentFrame should have zero border and padding");
+  // XXX Whether or not we can actually have an inline child is not speced yet.
+  bool inlineChild = child->StyleDisplay()->IsInlineOutsideStyle();
+  if (inlineChild) {
+    childReflowState.SetComputedISize(0);
+  }
+
   // Ignore child's margin.
 
   nsReflowStatus childStatus;
   nscoord containerWidth = aReflowState.ComputedWidth();
-  if (containerWidth == NS_UNCONSTRAINEDSIZE) {
-    containerWidth = 0;
-  }
 
   // Child is at offset (0, 0), since we are responsible for it's margin, and
   // we have not border or padding.
   ReflowChild(child, aPresContext, childDesiredSize,
               childReflowState, wm, LogicalPoint(wm, 0, 0), containerWidth, 0,
               childStatus);
-  //MOZ_ASSERT(NS_FRAME_IS_FULLY_COMPLETE(childStatus),
-              //"We gave our child unconstrained height, so it should be complete");
-
-  //nscoord wrappersMarginBoxHeight = childDesiredSize.Height() +
-    //childReflowState.ComputedPhysicalMargin().TopBottom();
-
-  //if (contentBoxHeight == NS_INTRINSICSIZE) {
-    //// We are intrinsically sized -- we should shrinkwrap the outer wrapper's
-    //// height:
-    //contentBoxHeight = wrappersMarginBoxHeight;
-
-    //// Make sure we obey min/max-height in the case when we're doing intrinsic
-    //// sizing (we get it for free when we have a non-intrinsic
-    //// aReflowState.ComputedHeight()).  Note that we do this before
-    //// adjusting for borderpadding, since mComputedMaxHeight and
-    //// mComputedMinHeight are content heights.
-    //contentBoxHeight =
-      //NS_CSS_MINMAX(contentBoxHeight,
-                    //aReflowState.ComputedMinHeight(),
-                    //aReflowState.ComputedMaxHeight());
-  //}
-
-  //// Center child vertically
-  //nscoord extraSpace = contentBoxHeight - wrappersMarginBoxHeight;
-  //yoffset += std::max(0, extraSpace / 2);
+  MOZ_ASSERT(NS_FRAME_IS_FULLY_COMPLETE(childStatus),
+              "We gave our child unconstrained height, so it should be complete");
 
   // Place the child
   FinishReflowChild(child, aPresContext, childDesiredSize,
                     &childReflowState, wm, LogicalPoint(wm, 0, 0),
                     containerWidth, 0);
 
-  // FIXME: Should this be set to zero?
-  aMetrics.SetBlockStartAscent(0);
+  // XXX See above.
+  if (inlineChild) {
+    aMetrics.SetBlockStartAscent(child->GetLogicalBaseline(wm));
+  } else {
+    aMetrics.SetBlockStartAscent(0);
+  }
 
-  aMetrics.SetSize(wm, childReflowState.ComputedSize(wm));
+  // XXX Why can't the following use childReflowState.ComputedSize(wm)?
+  aMetrics.SetSize(wm, childReflowState.ComputedLogicalBorderPadding().Size(wm));
 
   aMetrics.SetOverflowAreasToDesiredBounds();
 
-  if (child) {
-    ConsiderChildOverflow(aMetrics.mOverflowAreas, child);
-  }
+  ConsiderChildOverflow(aMetrics.mOverflowAreas, child);
 
   FinishAndStoreOverflow(&aMetrics);
 
   aStatus = NS_FRAME_COMPLETE;
 
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
 }
 
-//void
-//nsContainmentFrame::Reflow(nsPresContext*           aPresContext,
-                           //nsHTMLReflowMetrics&     aMetrics,
-                           //const nsHTMLReflowState& aReflowState,
-                           //nsReflowStatus&          aStatus)
-//{
-  //MarkInReflow();
-  //DO_GLOBAL_REFLOW_COUNT("nsContainmentFrame");
-  //DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
-
-  //nscoord consumedBSize = GetConsumedBSize();
-
-  //nsBlockReflowState state(aReflowState, aPresContext, this,
-                           //false, false,
-                           //false, consumedBSize);
-
-  //nsReflowStatus ocStatus = NS_FRAME_COMPLETE;
-
-  //LazyMarkLinesDirty();
-
-  //ReflowDirtyLines(state);
-
-  //NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
-
-  //WritingMode wm = state.mReflowState.GetWritingMode();
-  //const LogicalMargin& borderPadding = state.BorderPadding();
-
-  //LogicalSize finalSize(wm);
-  //finalSize.ISize(wm) =
-    //NSCoordSaturatingAdd(NSCoordSaturatingAdd(borderPadding.IStart(wm),
-                                              //aReflowState.ComputedISize()),
-                        //borderPadding.IEnd(wm));
-
-  //nscoord contentBSize = state.mBCoord - borderPadding.BStart(wm);
-  //nscoord autoBSize = aReflowState.ApplyMinMaxBSize(contentBSize);
-  //autoBSize += borderPadding.BStart(wm) + borderPadding.BEnd(wm);
-  //finalSize.BSize(wm) = std::max(0, autoBSize);
-
-  //aMetrics.SetSize(wm, finalSize);
-
-  //FinishAndStoreOverflow(&aMetrics);
-
-  //aStatus = NS_FRAME_COMPLETE;
-  //NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
-//}
-
-//void
-//nsContainmentFrame::ComputeFinalSize2(const nsHTMLReflowState& aReflowState,
-                               //nsBlockReflowState&      aState,
-                               //nsHTMLReflowMetrics&     aMetrics,
-                               //nscoord*                 aBEndEdgeOfChildren)
-//{
-  //WritingMode wm = aState.mReflowState.GetWritingMode();
-  //const LogicalMargin& borderPadding = aState.BorderPadding();
-
-  //LogicalSize finalSize(wm);
-  //finalSize.ISize(wm) =
-    //NSCoordSaturatingAdd(NSCoordSaturatingAdd(borderPadding.IStart(wm),
-                                              //aReflowState.ComputedISize()),
-                         //borderPadding.IEnd(wm));
-
-  //nscoord contentBSize = aState.mBCoord - borderPadding.BStart(wm);
-  //nscoord autoBSize = aReflowState.ApplyMinMaxBSize(contentBSize);
-  //autoBSize += borderPadding.BStart(wm) + borderPadding.BEnd(wm);
-  //finalSize.BSize(wm) = std::max(0, autoBSize);
-
-  //aMetrics.SetSize(wm, finalSize);
-//}
-
-
-//void
-//nsContainmentFrame::Reflow(nsPresContext*           aPresContext,
-                           //nsHTMLReflowMetrics&     aMetrics,
-                           //const nsHTMLReflowState& aReflowState,
-                           //nsReflowStatus&          aStatus)
-//{
-  //MarkInReflow();
-  //DO_GLOBAL_REFLOW_COUNT("nsContainmentFrame");
-  //DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
-  ////nsHTMLReflowState childReflowState(aReflowState);
-  //// Should we pass aMetrics's flags here?
-  ////nsHTMLReflowMetrics childMetrics(aMetrics.GetWritingMode());
-    ////mMinWidth = child->mMinWidth;
-    ////mMinHeight = child->mMinHeight;
-    ////mPrefWidth = child->mPrefWidth;
-    ////mPrefHeight = child->mPrefHeight;
-
-  ////NS_ASSERTION(aReflowState.ComputedWidth() != NS_UNCONSTRAINEDSIZE,
-               ////"Shouldn't have unconstrained stuff here "
-               ////"Thanks to the rules of reflow");
-  ////NS_ASSERTION(NS_INTRINSICSIZE != aReflowState.ComputedHeight(),
-               ////"Shouldn't have unconstrained stuff here "
-               ////"thanks to ComputeAutoSize");
-
-  //WritingMode wm = aReflowState.GetWritingMode();
-
-  ////LogicalSize finalSize(wm,
-                        ////aReflowState.ComputedISize(),
-                        ////aReflowState.ComputedBSize());
-
-  ////{
-    ////WritingMode wm = aReflowState.GetWritingMode();
-    ////if (finalSize.ISize(wm) == NS_UNCONSTRAINEDSIZE) {
-      ////finalSize.ISize(wm) = 0;
-    ////}
-    ////if (finalSize.BSize(wm) == NS_UNCONSTRAINEDSIZE) {
-      ////finalSize.BSize(wm) = 0;
-    ////}
-    ////finalSize.ISize(wm) += aReflowState.ComputedLogicalBorderPadding().IStartEnd(wm);
-    ////finalSize.BSize(wm) += aReflowState.ComputedLogicalBorderPadding().BStartEnd(wm);
-  ////}
-  //////AddBordersAndPadding(aReflowState, finalSize);
-  ////aMetrics.SetSize(wm, finalSize);
-
-  ////aMetrics.SetOverflowAreasToDesiredBounds();
-
-  //NS_ASSERTION(mFrames.FirstChild() && !mFrames.FirstChild()->GetNextSibling(),
-               //"nsContainmentFrame should have exactly one child");
-
-  //if (mFrames.FirstChild()) {
-    //nsIFrame *child = mFrames.FirstChild();
-    ////nsReflowStatus childStatus;
-    ////// Is this the correct aAvailableSpace?
-    ////nsHTMLReflowState childReflowState(aPresContext, this, aReflowState.rendContext, aMetrics.Size(wm), 0);
-    ////childReflowState.mCBReflowState = &childReflowState;
-    ////nsFloatManager floatManager(aPresContext->PresShell(), wm);
-    ////childReflowState.mFloatManager = &floatManager;
-    ////nsHTMLReflowMetrics childMetrics(aMetrics.GetWritingMode());
-    ////printf("CONTAIN: Reflowing child.\n");
-    ////child->Reflow(aPresContext, childMetrics, childReflowState, childStatus);
-    ////child->Reflow(aPresContext, childMetrics, aReflowState, childStatus);
-    ////child->Reflow(aPresContext, aMetrics, aReflowState, childStatus);
-    //child->Reflow(aPresContext, aMetrics, aReflowState, aStatus);
-    //LogicalPoint pos(wm, 0, 0);
-    //nscoord containerWidth = aReflowState.AvailableSize(wm).Width(wm);
-    //FinishReflowChild(child, aPresContext, aMetrics, &aReflowState, wm, pos, containerWidth, 0);
-  //}
-  ////mRect = child->mRect;
-
-
-  ////aStatus = NS_FRAME_COMPLETE;
-
-  ////NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
-                 ////("exit nsLeafFrame::DoReflow: size=%d,%d",
-                  ////aMetrics.ISize(wm), aMetrics.BSize(wm)));
-
-  //NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
-
-  ////aMetrics.SetOverflowAreasToDesiredBounds();
-
-  ////nsLeafFrame::Reflow(aPresContext, aMetrics, aReflowState, aStatus);
-
-  ////aMetrics.ClearSize();
-  ////aMetrics.mOverflowAreas.UnionWith(childMetrics.mOverflowAreas);
-
-  ////aStatus = NS_FRAME_COMPLETE;
-  ////NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
-
-  ////NS_ASSERTION(mFrames.FirstChild() && !mFrames.FirstChild()->GetNextSibling(),
-               ////"nsContainmentFrame should have exactly one child");
-
-  ////if (mFrames.FirstChild()) {
-    ////// Is this the correct aAvailableSpace?
-    ////nsHTMLReflowState childReflowState(aPresContext, this, aReflowState.rendContext, aMetrics.Size(wm), 0);
-    ////childReflowState.mCBReflowState = &childReflowState;
-    ////nsFloatManager floatManager(aPresContext->PresShell(), wm);
-    ////childReflowState.mFloatManager = &floatManager;
-    ////nsReflowStatus childStatus;
-    ////nsHTMLReflowMetrics childMetrics(aMetrics.GetWritingMode());
-    ////printf("CONTAIN: Reflowing child.\n");
-    ////nsIFrame *child = mFrames.FirstChild();
-    ////child->Reflow(aPresContext, childMetrics, childReflowState, childStatus);
-    //////child->Reflow(aPresContext, childMetrics, aReflowState, childStatus);
-  ////}
-//}
-
 #ifdef DEBUG_FRAME_DUMP
 nsresult
 nsContainmentFrame::GetFrameName(nsAString& aResult) const
 {
   return MakeFrameName(NS_LITERAL_STRING("Containment"), aResult);
 }
 #endif
diff --git a/layout/generic/nsContainmentFrame.h b/layout/generic/nsContainmentFrame.h
--- a/layout/generic/nsContainmentFrame.h
+++ b/layout/generic/nsContainmentFrame.h
@@ -21,19 +21,15 @@ public:
     : nsContainerFrame(aContext)
   {
   }
 
   virtual void Reflow(nsPresContext* aPresContext,
                       nsHTMLReflowMetrics& aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nsReflowStatus& aStatus) override;
-  //void ComputeFinalSize2(const nsHTMLReflowState& aReflowState,
-                        //nsBlockReflowState&      aState,
-                        //nsHTMLReflowMetrics&     aMetrics,
-                        //nscoord*                 aBEndEdgeOfChildren);
 
 #ifdef DEBUG_FRAME_DUMP
   virtual nsresult GetFrameName(nsAString& aResult) const override;
 #endif // DEBUG
 };
 
 #endif /* nsContainmentFrame_h___ */
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -5,17 +5,16 @@
 
 /* state and methods used while laying out a single line of a block frame */
 
 // This has to be defined before nsLineLayout.h is included, because
 // nsLineLayout.h has a #include for plarena.h, which needs this defined:
 #define PL_ARENA_CONST_ALIGN_MASK (sizeof(void*)-1)
 #include "nsLineLayout.h"
 
-#include "LayoutLogging.h"
 #include "SVGTextFrame.h"
 #include "nsBlockFrame.h"
 #include "nsFontMetrics.h"
 #include "nsStyleConsts.h"
 #include "nsContainerFrame.h"
 #include "nsFloatManager.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
@@ -150,20 +149,20 @@ void
 nsLineLayout::BeginLineReflow(nscoord aICoord, nscoord aBCoord,
                               nscoord aISize, nscoord aBSize,
                               bool aImpactedByFloats,
                               bool aIsTopOfPage,
                               WritingMode aWritingMode,
                               const nsSize& aContainerSize)
 {
   NS_ASSERTION(nullptr == mRootSpan, "bad linelayout user");
-  LAYOUT_WARN_IF_FALSE(aISize != NS_UNCONSTRAINEDSIZE,
-                       "have unconstrained width; this should only result from "
-                       "very large sizes, not attempts at intrinsic width "
-                       "calculation");
+  NS_WARN_IF_FALSE(aISize != NS_UNCONSTRAINEDSIZE,
+                   "have unconstrained width; this should only result from "
+                   "very large sizes, not attempts at intrinsic width "
+                   "calculation");
 #ifdef DEBUG
   if ((aISize != NS_UNCONSTRAINEDSIZE) && CRAZY_SIZE(aISize)) {
     nsFrame::ListTag(stdout, mBlockReflowState->frame);
     printf(": Init: bad caller: width WAS %d(0x%x)\n",
            aISize, aISize);
   }
   if ((aBSize != NS_UNCONSTRAINEDSIZE) && CRAZY_SIZE(aBSize)) {
     nsFrame::ListTag(stdout, mBlockReflowState->frame);
@@ -440,39 +439,32 @@ nsLineLayout::BeginSpan(nsIFrame* aFrame
   nsFrame::ListTag(stdout, aFrame);
   printf(": BeginSpan leftEdge=%d rightEdge=%d\n", aIStart, aIEnd);
 #endif
 
   PerSpanData* psd = NewPerSpanData();
   // Link up span frame's pfd to point to its child span data
   PerFrameData* pfd = mCurrentSpan->mLastFrame;
   NS_ASSERTION(pfd->mFrame == aFrame, "huh?");
-  printf("pdf->mFrame = %p\n", pfd->mFrame);
-  printf("aFrame = %p\n", aFrame);
-  pfd->mFrame->List(stdout);
-  aFrame->List(stdout);
   pfd->mSpan = psd;
 
-  pfd->mFrame = aFrame;
-
   // Init new span
   psd->mFrame = pfd;
   psd->mParent = mCurrentSpan;
   psd->mReflowState = aSpanReflowState;
   psd->mIStart = aIStart;
   psd->mICoord = aIStart;
   psd->mIEnd = aIEnd;
   psd->mBaseline = aBaseline;
 
   nsIFrame* frame = aSpanReflowState->frame;
   psd->mNoWrap = !frame->StyleText()->WhiteSpaceCanWrap(frame) ||
                  mSuppressLineWrap ||
                  frame->StyleContext()->ShouldSuppressLineBreak();
   psd->mWritingMode = aSpanReflowState->GetWritingMode();
-  printf("psd->mNoWrap = %d\n", psd->mNoWrap);
 
   // Switch to new span
   mCurrentSpan = psd;
   mSpanDepth++;
 }
 
 nscoord
 nsLineLayout::EndSpan(nsIFrame* aFrame)
@@ -881,20 +873,20 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
 
   // Figure out whether we're talking about a textframe here
   nsIAtom* frameType = aFrame->GetType();
   bool isText = frameType == nsGkAtoms::textFrame;
   
   // Inline-ish and text-ish things don't compute their width;
   // everything else does.  We need to give them an available width that
   // reflects the space left on the line.
-  LAYOUT_WARN_IF_FALSE(psd->mIEnd != NS_UNCONSTRAINEDSIZE,
-                      "have unconstrained width; this should only result from "
-                      "very large sizes, not attempts at intrinsic width "
-                      "calculation");
+  NS_WARN_IF_FALSE(psd->mIEnd != NS_UNCONSTRAINEDSIZE,
+                   "have unconstrained width; this should only result from "
+                   "very large sizes, not attempts at intrinsic width "
+                   "calculation");
   nscoord availableSpaceOnLine = psd->mIEnd - psd->mICoord;
 
   // Setup reflow state for reflowing the frame
   Maybe<nsHTMLReflowState> reflowStateHolder;
   if (!isText) {
     // Compute the available size for the frame. This available width
     // includes room for the side margins.
     // For now, set the available block-size to unconstrained always.
@@ -3055,20 +3047,20 @@ nsLineLayout::TextAlignLine(nsLineBox* a
                             bool aIsLastLine)
 {
   /**
    * NOTE: aIsLastLine ain't necessarily so: it is correctly set by caller
    * only in cases where the last line needs special handling.
    */
   PerSpanData* psd = mRootSpan;
   WritingMode lineWM = psd->mWritingMode;
-  LAYOUT_WARN_IF_FALSE(psd->mIEnd != NS_UNCONSTRAINEDSIZE,
-                       "have unconstrained width; this should only result from "
-                       "very large sizes, not attempts at intrinsic width "
-                       "calculation");
+  NS_WARN_IF_FALSE(psd->mIEnd != NS_UNCONSTRAINEDSIZE,
+                   "have unconstrained width; this should only result from "
+                   "very large sizes, not attempts at intrinsic width "
+                   "calculation");
   nscoord availISize = psd->mIEnd - psd->mIStart;
   nscoord remainingISize = availISize - aLine->ISize();
 #ifdef NOISY_INLINEDIR_ALIGN
   nsFrame::ListTag(stdout, mBlockReflowState->frame);
   printf(": availISize=%d lineBounds.IStart=%d lineISize=%d delta=%d\n",
          availISize, aLine->IStart(), aLine->ISize(), remainingISize);
 #endif
 
diff --git a/layout/reftests/css-contain/layout-inline-zero.html b/layout/reftests/css-contain/layout-inline-zero.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-contain/layout-inline-zero.html
@@ -0,0 +1,34 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <meta charset="utf-8">
+  <style>
+  body {
+    margin: 0;
+  }
+  .container {
+    contain: layout;
+    background: red;
+    border: 1em solid green;
+    //width: 6em;
+    //height: 2em;
+  }
+  .container-ref {
+    display: block;
+    background: red;
+    border: 1em solid green;
+    width: 0;
+    height: 0;
+  }
+  .inner-ref {
+    position: absolute;
+    left: 1em;
+  }
+  </style>
+</head>
+<body class="reftest-paint">
+  <span class="container">Test span.</span>
+  <!--<span class="container-ref"><span class="inner-ref">Test span.</span></span>-->
+  <!--<div class="container-ref"><span class="inner-ref">Test span.</span></div>-->
+</body>
+</html>
diff --git a/layout/reftests/css-contain/layout-zero.html b/layout/reftests/css-contain/layout-zero.html
--- a/layout/reftests/css-contain/layout-zero.html
+++ b/layout/reftests/css-contain/layout-zero.html
@@ -20,18 +20,19 @@
   <div class="fun">
     <div>
       This is some content before the contained element.
     </div>
     <div>
       This is a parent of the contained element.
       <div class="container">
         <div>
-    Lorem ipsum dolor sit amet, cu per agam quaerendum reprehendunt, scripta vivendo perfecto vis eu. Sea fastidii principes an. Sed in duis senserit, et cum impedit voluptaria, in nam sumo affert recteque. Sanctus suavitate voluptatibus te ius. Eos id insolens gloriatur repudiandae, vim in adhuc principes reprimique, vis ad omnium pericula reprimique.
+    Lorem ipsum dolor sit amet
         </div>
+    <!--Lorem ipsum dolor sit amet, cu per agam quaerendum reprehendunt, scripta vivendo perfecto vis eu. Sea fastidii principes an. Sed in duis senserit, et cum impedit voluptaria, in nam sumo affert recteque. Sanctus suavitate voluptatibus te ius. Eos id insolens gloriatur repudiandae, vim in adhuc principes reprimique, vis ad omnium pericula reprimique.-->
       </div>
     </div>
     <div>
       This is some content after the contained element.
     </div>
   </div>
 </body>
 </html>
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -5708,16 +5708,24 @@ nsRuleNode::ComputeDisplayData(void* aSt
 
       // Note that it's OK to cache this struct in the ruletree
       // because it's fine as-is for any style context that points to
       // it directly, and any use of it as aStartStruct (e.g. if a
       // more specific rule sets "float: none") will use
       // mOriginalDisplay, which we have carefully not changed.
     }
 
+    if (display->mContain & (NS_STYLE_CONTAIN_PAINT | NS_STYLE_CONTAIN_LAYOUT)) {
+      // This is supposed to cause contain: paint and contain: layout elements
+      // to become formatting contexts. However, exactly what formatting
+      // context means has not been specificed yet.
+      // Most likely, the intended behavior is similar to EnsureBlockDisplay.
+      // XXX This will convert 'inline' to 'block' (instead of 'inline-block'). Is that right?
+      EnsureBlockDisplay(display->mDisplay);
+    }
   }
 
   /* Convert the nsCSSValueList into an nsTArray<nsTransformFunction *>. */
   const nsCSSValue* transformValue = aRuleData->ValueForTransform();
   switch (transformValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
 
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -519,8 +519,16 @@ div:-moz-native-anonymous.moz-custom-con
   position: fixed;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
 
   z-index: 2147483648;
 }
+
+*|*::-moz-containment {
+  /* Do to the strange way containment frames are created, this actually
+   * inherits from the *child* of the containment frame.
+   * See BuildContainment() in nsCSSFrameConstructor.cpp for details.
+   */
+  display: inherit;
+}
