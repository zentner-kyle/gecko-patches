# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  5ca9cc79ba1d4aa1f96801a602182bde3a7ab04c

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -669,16 +669,20 @@ nsBlockFrame::CheckIntrinsicCacheAgainst
 nsBlockFrame::GetMinISize(nsRenderingContext *aRenderingContext)
 {
   nsIFrame* firstInFlow = FirstContinuation();
   if (firstInFlow != this)
     return firstInFlow->GetMinISize(aRenderingContext);
 
   DISPLAY_MIN_WIDTH(this, mMinWidth);
 
+  if (StyleDisplay()->IsContainLayout()) {
+    return 0;
+  }
+
   CheckIntrinsicCacheAgainstShrinkWrapState();
 
   if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
     return mMinWidth;
 
 #ifdef DEBUG
   if (gNoisyIntrinsic) {
     IndentBy(stdout, gNoiseIndent);
@@ -756,16 +760,20 @@ nsBlockFrame::GetPrefISize(nsRenderingCo
   nsIFrame* firstInFlow = FirstContinuation();
   if (firstInFlow != this)
     return firstInFlow->GetPrefISize(aRenderingContext);
 
   DISPLAY_PREF_WIDTH(this, mPrefWidth);
 
   CheckIntrinsicCacheAgainstShrinkWrapState();
 
+  if (StyleDisplay()->IsContainLayout()) {
+    return mPrefWidth;
+  }
+
   if (mPrefWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
     return mPrefWidth;
 
 #ifdef DEBUG
   if (gNoisyIntrinsic) {
     IndentBy(stdout, gNoiseIndent);
     ListTag(stdout);
     printf(": GetPrefISize\n");
@@ -1032,16 +1040,20 @@ nsBlockFrame::Reflow(nsPresContext*     
   }
 #endif
 
   const nsHTMLReflowState *reflowState = &aReflowState;
   WritingMode wm = aReflowState.GetWritingMode();
   nscoord consumedBSize = GetConsumedBSize();
   nscoord effectiveComputedBSize = GetEffectiveComputedBSize(aReflowState,
                                                              consumedBSize);
+
+  nscoord originalISize = aReflowState.ComputedISize();
+  //nscoord originalISize = aMetrics.ISize(wm);
+
   Maybe<nsHTMLReflowState> mutableReflowState;
   // If we have non-auto block size, we're clipping our kids and we fit,
   // make sure our kids fit too.
   if (aReflowState.AvailableBSize() != NS_UNCONSTRAINEDSIZE &&
       aReflowState.ComputedBSize() != NS_AUTOHEIGHT &&
       ShouldApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
     LogicalMargin blockDirExtras = aReflowState.ComputedLogicalBorderPadding();
     if (GetLogicalSkipSides().BStart()) {
@@ -1114,17 +1126,17 @@ nsBlockFrame::Reflow(nsPresContext*     
   // ALWAYS drain overflow. We never want to leave the previnflow's
   // overflow lines hanging around; block reflow depends on the
   // overflow line lists being cleared out between reflow passes.
   DrainOverflowLines();
 
   // Handle paginated overflow (see nsContainerFrame.h)
   nsOverflowAreas ocBounds;
   nsReflowStatus ocStatus = NS_FRAME_COMPLETE;
-  if (GetPrevInFlow()) {
+  if (GetPrevInFlow() && !StyleDisplay()->IsContainLayout()) {
     ReflowOverflowContainerChildren(aPresContext, *reflowState, ocBounds, 0,
                                     ocStatus);
   }
 
   // Now that we're done cleaning up our overflow container lists, we can
   // give |state| its nsOverflowContinuationTracker.
   nsOverflowContinuationTracker tracker(this, false);
   state.mOverflowTracker = &tracker;
@@ -1251,17 +1263,17 @@ nsBlockFrame::Reflow(nsPresContext*     
     // Otherwise just leave the bullet where it is, up against our
     // block-start padding.
   }
 
   CheckFloats(state);
 
   // Compute our final size
   nscoord blockEndEdgeOfChildren;
-  ComputeFinalSize(*reflowState, state, aMetrics, &blockEndEdgeOfChildren);
+  ComputeFinalSize(*reflowState, state, aMetrics, &blockEndEdgeOfChildren, originalISize);
 
   // If the block direction is right-to-left, we need to update the bounds of
   // lines that were placed relative to mContainerWidth during reflow, as
   // we typically do not know the true container width (block-dir size of the
   // finished paragraph/block) until we've reflowed all its children. So we
   // use a "fake" mContainerWidth during reflow (see nsBlockReflowState's
   // constructor) and then fix up the positions of the lines here, once the
   // final block size is known.
@@ -1452,33 +1464,39 @@ nsBlockFrame::CheckForCollapsedBEndMargi
   }
   // not reached
 }
 
 void
 nsBlockFrame::ComputeFinalSize(const nsHTMLReflowState& aReflowState,
                                nsBlockReflowState&      aState,
                                nsHTMLReflowMetrics&     aMetrics,
-                               nscoord*                 aBEndEdgeOfChildren)
+                               nscoord*                 aBEndEdgeOfChildren,
+                               nscoord                  aOriginalISize)
 {
   WritingMode wm = aState.mReflowState.GetWritingMode();
   const LogicalMargin& borderPadding = aState.BorderPadding();
 #ifdef NOISY_FINAL_SIZE
   ListTag(stdout);
   printf(": mBCoord=%d mIsBEndMarginRoot=%s mPrevBEndMargin=%d bp=%d,%d\n",
          aState.mBCoord, aState.GetFlag(BRS_ISBENDMARGINROOT) ? "yes" : "no",
          aState.mPrevBEndMargin,
          borderPadding.BStart(wm), borderPadding.BEnd(wm));
 #endif
 
   // Compute final inline size
   LogicalSize finalSize(wm);
+  (void)aOriginalISize;
+  //nscoord contentISize = StyleDisplay()->IsContainLayout() ? aOriginalISize : aReflowState.ComputedISize();
+  //nscoord contentISize = StyleDisplay()->IsContainLayout() ? aMetrics.ISize(wm) : aReflowState.ComputedISize();
+  nscoord contentISize = aReflowState.ComputedISize();
+  //nscoord contentISize = StyleDisplay()->IsContainLayout() ? 0 : aReflowState.ComputedISize();
   finalSize.ISize(wm) =
     NSCoordSaturatingAdd(NSCoordSaturatingAdd(borderPadding.IStart(wm),
-                                              aReflowState.ComputedISize()),
+                                              contentISize),
                          borderPadding.IEnd(wm));
 
   // Return block-end margin information
   // rbs says he hit this assertion occasionally (see bug 86947), so
   // just set the margin to zero and we'll figure out why later
   //NS_ASSERTION(aMetrics.mCarriedOutBEndMargin.IsZero(),
   //             "someone else set the margin");
   nscoord nonCarriedOutBDirMargin = 0;
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -417,17 +417,18 @@ protected:
                                 nscoord aNewContainerWidth);
 
   // helper for SlideLine and UpdateLineContainerWidth
   void MoveChildFramesOfLine(nsLineBox* aLine, nscoord aDeltaBCoord);
 
   void ComputeFinalSize(const nsHTMLReflowState& aReflowState,
                         nsBlockReflowState&      aState,
                         nsHTMLReflowMetrics&     aMetrics,
-                        nscoord*                 aBottomEdgeOfChildren);
+                        nscoord*                 aBottomEdgeOfChildren,
+                        nscoord                  aOriginalISize);
 
   void ComputeOverflowAreas(const nsRect&         aBounds,
                             const nsStyleDisplay* aDisplay,
                             nscoord               aBottomEdgeOfChildren,
                             nsOverflowAreas&      aOverflowAreas);
 
   /**
    * Add the frames in aFrameList to this block after aPrevSibling.
