# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  dc07c78b3bfe361f4f7f7c17f4867af1ae18b861

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -11389,18 +11389,18 @@ nsCSSFrameConstructor::CreateListBoxCont
     // any frame at all
     const nsStyleDisplay* display = styleContext->StyleDisplay();
 
     if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
       *aNewFrame = nullptr;
       return NS_OK;
     }
 
+    MaybePushStyleRoot(aParentFrame);
     BeginUpdate();
-    MaybePushStyleRoot(aParentFrame);
 
     FrameConstructionItemList items;
     AddFrameConstructionItemsInternal(state, aChild, aParentFrame,
                                       aChild->NodeInfo()->NameAtom(),
                                       aChild->GetNameSpaceID(),
                                       true, styleContext,
                                       ITEM_ALLOW_XBL_BASE, nullptr, items);
     ConstructFramesFromItemList(state, items, aParentFrame, frameItems);
@@ -12257,18 +12257,18 @@ nsCSSFrameConstructor::ReframeContaining
                                   true, aFlags, nullptr);
 }
 
 nsresult
 nsCSSFrameConstructor::GenerateChildFrames(nsContainerFrame* aFrame)
 {
   {
     nsAutoScriptBlocker scriptBlocker;
+    MaybePushStyleRoot(aFrame);
     BeginUpdate();
-    MaybePushStyleRoot(aFrame);
 
     nsFrameItems childItems;
     nsFrameConstructorState state(mPresShell, nullptr, nullptr, nullptr);
     // We don't have a parent frame with a pending binding constructor here,
     // so no need to worry about ordering of the kids' constructors with it.
     // Pass null for the PendingBinding.
     ProcessChildren(state, aFrame->GetContent(), aFrame->StyleContext(),
                     aFrame, false, childItems, false,
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -2031,23 +2031,28 @@ private:
   nsIFrame* GetStyleRoot() {
     if (mStyleRoots.Length() < 1) {
       return nullptr;
     }
     return mStyleRoots.LastElement();
   }
 
   void MaybePushStyleRoot(nsIFrame* aPotentialRoot) {
-    if (aPotentialRoot->StyleDisplay()->IsContainStyle()) {
-      mStyleRoots.AppendElement(aPotentialRoot);
+    if (aPotentialRoot) {
+      if (aPotentialRoot->StyleDisplay()->IsContainStyle()) {
+        mStyleRoots.AppendElement(aPotentialRoot);
+      } else if (aPotentialRoot->StyleContext()->HasContainStyle() &&
+                !GetStyleRoot()) {
+        mStyleRoots.AppendElement(FindStyleRoot(aPotentialRoot));
+      }
     }
   }
 
   void MaybePopStyleRoot(nsIFrame* aPotentialRoot) {
-    if (GetStyleRoot() == aPotentialRoot) {
+    if (aPotentialRoot && GetStyleRoot() == aPotentialRoot) {
       mStyleRoots.RemoveElementAt(mStyleRoots.Length() - 1);
     }
   }
 
   void QuotesDirty() {
     NS_PRECONDITION(mUpdateCount != 0, "Instant quote updates are bad news");
     mQuotesDirty = true;
     mDocument->SetNeedLayoutFlush();
diff --git a/layout/base/nsCounterManager.cpp b/layout/base/nsCounterManager.cpp
--- a/layout/base/nsCounterManager.cpp
+++ b/layout/base/nsCounterManager.cpp
@@ -166,16 +166,19 @@ nsCounterList::SetScope(nsCounterNode *a
              // A reset's outer scope can't be a scope created by a sibling.
         if (!(aNode->mType == nsCounterNode::RESET &&
               nodeContent == startContent) &&
               // everything is inside the root (except the case above,
               // a second reset on the root)
             ((!startContent ||
              nsContentUtils::ContentIsDescendantOf(nodeContent,
                                                    startContent)) ||
+             // We hit the beginning of the list, but not necessarily the top
+             // of the frame tree. This case should only be hit from using
+             // style containment.
              !start->mScopePrev)) {
             aNode->mScopeStart = start;
             aNode->mScopePrev  = prev;
             return;
         }
     }
 
     aNode->mScopeStart = nullptr;
diff --git a/layout/base/nsCounterManager.h b/layout/base/nsCounterManager.h
--- a/layout/base/nsCounterManager.h
+++ b/layout/base/nsCounterManager.h
@@ -273,20 +273,19 @@ public:
     typedef nsClassHashtable<nsStringHashKey, nsCounterList> NameTable;
 
 private:
     // for |AddCounterResetsAndIncrements| only
     bool AddResetOrIncrement(nsIFrame *aRoot, nsIFrame *aFrame, int32_t aIndex,
                                const nsStyleCounterData *aCounterData,
                                nsCounterNode::Type aType);
 
-    NameTable* GetNames(nsIFrame* aRoot) {
-        //return mRoots.Get(nsPtrHashKey<const nsIFrame>(aRoot));
+    NameTable* GetNames(nsIFrame* aRoot, bool aShouldCreate = true) {
         NameTable* names = mRoots.Get(aRoot);
-        if (!names) {
+        if (!names && aShouldCreate) {
             names = new NameTable();
             mRoots.Put(aRoot, names);
         }
         return names;
     }
     nsClassHashtable<nsPtrHashKey<const nsIFrame>, NameTable> mRoots;
 };
 
