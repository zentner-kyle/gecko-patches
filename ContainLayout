# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  3541f6a3c013b4ab1835cd430102e6bf6aa24329
Bug 1178895 - Patch 1: Implement CSS 'contain: layout'.

diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -32,16 +32,17 @@
 #include "nsPresShell.h"
 #include "nsIPresShell.h"
 #include "nsUnicharUtils.h"
 #include "nsStyleSet.h"
 #include "nsViewManager.h"
 #include "nsStyleConsts.h"
 #include "nsIDOMXULElement.h"
 #include "nsContainerFrame.h"
+#include "nsContainmentFrame.h"
 #include "nsNameSpaceManager.h"
 #include "nsIComboboxControlFrame.h"
 #include "nsIListControlFrame.h"
 #include "nsIDOMCharacterData.h"
 #include "nsPlaceholderFrame.h"
 #include "nsTableRowGroupFrame.h"
 #include "nsIFormControl.h"
 #include "nsCSSAnonBoxes.h"
@@ -1205,17 +1206,17 @@ nsFrameConstructorState::AddChild(nsIFra
                                                        aStyleContext,
                                                        aParentFrame,
                                                        nullptr,
                                                        placeholderType);
 
     placeholderFrame->AddStateBits(mAdditionalStateBits);
     // Add the placeholder frame to the flow
     aFrameItems.AddChild(placeholderFrame);
-  }
+  } 
 #ifdef DEBUG
   else {
     NS_ASSERTION(aNewFrame->GetParent() == aParentFrame,
                  "In-flow frame has wrong parent");
   }
 #endif
 
   if (aInsertAfter) {
@@ -3744,21 +3745,30 @@ nsCSSFrameConstructor::ConstructFrameFro
   } else {
     ancestorPusher.PushStyleScope(content);
   }
 
   nsIFrame* newFrame;
   nsIFrame* primaryFrame;
   nsStyleContext* const styleContext = aItem.mStyleContext;
   const nsStyleDisplay* display = styleContext->StyleDisplay();
+  nsFrameItems containedItems;
+  nsFrameItems *items = &aFrameItems;
+  nsContainerFrame *container = nullptr;
+  if (display->IsLayoutContaining()) {
+  //if (aParentFrame->StyleDisplay()->IsLayoutContaining()) {
+    items = &containedItems;
+    container = BuildContainment(aState, content, styleContext,
+                                 aParentFrame, aFrameItems);
+    aParentFrame = container;
+  }
   if (bits & FCDATA_FUNC_IS_FULL_CTOR) {
     newFrame =
       (this->*(data->mFullConstructor))(aState, aItem, aParentFrame,
-                                        display, aFrameItems);
-    MOZ_ASSERT(newFrame, "Full constructor failed");
+                                        display, *items);
     primaryFrame = newFrame;
   } else {
     newFrame =
       (*data->mFunc.mCreationFunc)(mPresShell, styleContext);
 
     bool allowOutOfFlow = !(bits & FCDATA_DISALLOW_OUT_OF_FLOW);
     bool isPopup = aItem.mIsPopup;
     NS_ASSERTION(!isPopup ||
@@ -3825,17 +3835,17 @@ nsCSSFrameConstructor::ConstructFrameFro
         maybeAbsoluteContainingBlock = blockFrame;
         maybeAbsoluteContainingBlockStyleFrame = blockFrame;
       }
 
       // Our kids should go into the blockFrame
       newFrame = blockFrame;
     }
 
-    aState.AddChild(frameToAddToList, aFrameItems, content, styleContext,
+    aState.AddChild(frameToAddToList, *items, content, styleContext,
                     aParentFrame, allowOutOfFlow, allowOutOfFlow, isPopup);
 
     nsContainerFrame* newFrameAsContainer = do_QueryFrame(newFrame);
     if (newFrameAsContainer) {
 #ifdef MOZ_XUL
       // Icky XUL stuff, sadly
 
       if (aItem.mIsRootPopupgroup) {
@@ -3959,19 +3969,24 @@ nsCSSFrameConstructor::ConstructFrameFro
   // Even if mCreatingExtraFrames is set, we may need to SetPrimaryFrame for
   // generated content that doesn't have one yet.  Note that we have to examine
   // the frame bit, because by this point mIsGeneratedContent has been cleared
   // on aItem.
   if ((!aState.mCreatingExtraFrames ||
        ((primaryFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) &&
         !aItem.mContent->GetPrimaryFrame())) &&
        !(bits & FCDATA_SKIP_FRAMESET)) {
+       //&&
+       //!container) {
     aItem.mContent->SetPrimaryFrame(primaryFrame);
     ActiveLayerTracker::TransferActivityToFrame(aItem.mContent, primaryFrame);
   }
+  if (container) {
+    AddContainedChildren(aState, content, container, containedItems);
+  }
 }
 
 // after the node has been constructed and initialized create any
 // anonymous content a node needs.
 nsresult
 nsCSSFrameConstructor::CreateAnonymousFrames(nsFrameConstructorState& aState,
                                              nsIContent*              aParent,
                                              nsContainerFrame*        aParentFrame,
@@ -4442,16 +4457,48 @@ nsCSSFrameConstructor::BeginBuildingScro
 
   if (gfxScrollFrame) {
      gfxScrollFrame->SetInitialChildList(kPrincipalList, anonymousItems);
   }
 
   return scrolledChildStyle.forget();
 }
 
+nsContainerFrame*
+nsCSSFrameConstructor::BuildContainment(nsFrameConstructorState& aState,
+                                        nsIContent*              aContent,
+                                        nsStyleContext*          aContentStyle,
+                                        nsContainerFrame*        aParentFrame,
+                                        nsFrameItems            &aParentItems)
+{
+  nsRefPtr<nsStyleContext> containerStyle =
+    mPresShell->StyleSet()->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::containment,
+                                                     aContentStyle);
+
+  nsContainerFrame *container = new (mPresShell) nsContainmentFrame(containerStyle);
+  //containerStyle->StyleDisplay()->mDisplay = aContentStyle->StyleDisplay()->mDisplay;
+  //nsContainerFrame *container = NS_NewBlockFrame(mPresShell, containerStyle);
+  InitAndRestoreFrame(aState, aContent, aParentFrame, container);
+  aState.AddChild(container, aParentItems, aContent, aContentStyle,
+                  aParentFrame, true, true, false);
+
+  return container;
+}
+
+void
+nsCSSFrameConstructor::AddContainedChildren(nsFrameConstructorState& aState,
+                                            nsIContent*              aContent,
+                                            nsContainerFrame*        aContainer,
+                                            nsFrameItems            &aContained)
+{
+  CreateAnonymousFrames(aState, aContent, aContainer, nullptr, aContained);
+  aContainer->SetInitialChildList(kPrincipalList, aContained);
+  //aContent->SetPrimaryFrame(aContainer);
+}
+
 void
 nsCSSFrameConstructor::FinishBuildingScrollFrame(nsContainerFrame* aScrollFrame,
                                                  nsIFrame* aScrolledFrame)
 {
   nsFrameList scrolled(aScrolledFrame, aScrolledFrame);
   aScrollFrame->AppendFrames(kPrincipalList, scrolled);
 }
 
@@ -7985,29 +8032,32 @@ nsCSSFrameConstructor::ContentRemoved(ns
     if (gReallyNoisyContentUpdates) {
       aContainer->List(stdout, 0);
     }
   }
 #endif
 
   nsresult rv = NS_OK;
   nsIFrame* childFrame = aChild->GetPrimaryFrame();
+  while (childFrame && childFrame->StyleDisplay()->IsLayoutContaining()) {
+    childFrame = childFrame->GetParent();
+  }
   if (!childFrame || childFrame->GetContent() != aChild) {
     // XXXbz the GetContent() != aChild check is needed due to bug 135040.
     // Remove it once that's fixed.
     ClearUndisplayedContentIn(aChild, aContainer);
   }
   MOZ_ASSERT(!childFrame || !GetDisplayContentsStyleFor(aChild),
              "display:contents nodes shouldn't have a frame");
   if (!childFrame && GetDisplayContentsStyleFor(aChild)) {
     nsIFrame* ancestorFrame = nullptr;
     nsIContent* ancestor = aContainer;
     for (; ancestor; ancestor = ancestor->GetParent()) {
       ancestorFrame = ancestor->GetPrimaryFrame();
-      if (ancestorFrame) {
+      if (ancestorFrame && !ancestorFrame->StyleDisplay()->IsLayoutContaining()) {
         break;
       }
     }
     if (ancestorFrame) {
       nsTArray<nsIContent*>* generated = ancestorFrame->GetGenConPseudos();
       if (generated) {
         *aDidReconstruct = true;
         LAYOUT_PHASE_TEMP_EXIT();
@@ -10255,16 +10305,17 @@ nsCSSFrameConstructor::ConstructFramesFr
   CreateNeededAnonFlexOrGridItems(aState, aItems, aParentFrame);
   CreateNeededPseudoInternalRubyBoxes(aState, aItems, aParentFrame);
   CreateNeededPseudoSiblings(aState, aItems, aParentFrame);
 
   aItems.SetTriedConstructingFrames();
   for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
     NS_ASSERTION(iter.item().DesiredParentType() == GetParentType(aParentFrame),
                  "Needed pseudos didn't get created; expect bad things");
+    /// XXXkzentner: Maybe insert nsContainmentFrame here?
     ConstructFramesFromItem(aState, iter, aParentFrame, aFrameItems);
   }
 
   NS_ASSERTION(!aState.mHavePendingPopupgroup,
                "Should have proccessed it by now");
 }
 
 void
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -1615,16 +1615,28 @@ private:
   void
   BuildScrollFrame(nsFrameConstructorState& aState,
                    nsIContent*              aContent,
                    nsStyleContext*          aContentStyle,
                    nsIFrame*                aScrolledFrame,
                    nsContainerFrame*        aParentFrame,
                    nsContainerFrame*&       aNewFrame);
 
+  nsContainerFrame*
+  BuildContainment(nsFrameConstructorState& aState,
+                   nsIContent*              aContent,
+                   nsStyleContext*          aContentStyle,
+                   nsContainerFrame*        aParentFrame,
+                   nsFrameItems            &aParentItems);
+  void
+  AddContainedChildren(nsFrameConstructorState& aState,
+                      nsIContent*              aContent,
+                      nsContainerFrame*        aContainer,
+                      nsFrameItems            &aContained);
+
   // Builds the initial ScrollFrame
   already_AddRefed<nsStyleContext>
   BeginBuildingScrollFrame(nsFrameConstructorState& aState,
                            nsIContent*              aContent,
                            nsStyleContext*          aContentStyle,
                            nsContainerFrame*        aParentFrame,
                            nsIAtom*                 aScrolledPseudo,
                            bool                     aIsRoot,
diff --git a/layout/generic/moz.build b/layout/generic/moz.build
--- a/layout/generic/moz.build
+++ b/layout/generic/moz.build
@@ -118,16 +118,17 @@ UNIFIED_SOURCES += [
     'nsBlockFrame.cpp',
     'nsBlockReflowContext.cpp',
     'nsBlockReflowState.cpp',
     'nsBRFrame.cpp',
     'nsBulletFrame.cpp',
     'nsCanvasFrame.cpp',
     'nsColumnSetFrame.cpp',
     'nsContainerFrame.cpp',
+    'nsContainmentFrame.cpp',
     'nsFirstLetterFrame.cpp',
     'nsFlexContainerFrame.cpp',
     'nsFloatManager.cpp',
     'nsFontInflationData.cpp',
     'nsFrame.cpp',
     'nsFrameList.cpp',
     'nsFrameSetFrame.cpp',
     'nsFrameState.cpp',
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -5129,16 +5129,18 @@ nsBlockFrame::AddFrames(nsFrameList& aFr
     NS_ASSERTION(!aPrevSibling || aPrevSibling->GetNextSibling() == newFrame,
                  "Unexpected aPrevSibling");
     NS_ASSERTION(newFrame->GetType() != nsGkAtoms::placeholderFrame ||
                  (!newFrame->IsAbsolutelyPositioned() &&
                   !newFrame->IsFloating()),
                  "Placeholders should not float or be positioned");
 
     bool isBlock = newFrame->IsBlockOutside();
+    //newFrame->List(stdout);
+    //printf("isBlock = %d\n", isBlock);
 
     // If the frame is a block frame, or if there is no previous line or if the
     // previous line is a block line we need to make a new line.  We also make
     // a new line, as an optimization, in the two cases we know we'll need it:
     // if the previous line ended with a <br>, or if it has significant whitespace
     // and ended in a newline.
     if (isBlock || prevSibLine == lineList->end() || prevSibLine->IsBlock() ||
         (aPrevSibling && ShouldPutNextSiblingOnNewLine(aPrevSibling))) {
diff --git a/layout/generic/nsContainmentFrame.cpp b/layout/generic/nsContainmentFrame.cpp
new file mode 100644
--- /dev/null
+++ b/layout/generic/nsContainmentFrame.cpp
@@ -0,0 +1,100 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+#include "nsContainmentFrame.h"
+
+#include "nsFrameManager.h"
+#include "nsLayoutUtils.h"
+#include "mozilla/AutoRestore.h"
+
+NS_IMPL_FRAMEARENA_HELPERS(nsContainmentFrame)
+
+#ifdef DEBUG
+NS_QUERYFRAME_HEAD(nsContainmentFrame)
+  NS_QUERYFRAME_ENTRY(nsContainmentFrame)
+NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)
+#endif
+
+void
+nsContainmentFrame::Reflow(nsPresContext*           aPresContext,
+                           nsHTMLReflowMetrics&     aMetrics,
+                           const nsHTMLReflowState& aReflowState,
+                           nsReflowStatus&          aStatus)
+{
+  MarkInReflow();
+  DO_GLOBAL_REFLOW_COUNT("nsNumberControlFrame");
+  DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
+
+  nsIFrame* child = mFrames.FirstChild();
+  MOZ_ASSERT(child && !mFrames.FirstChild()->GetNextSibling(),
+             "nsContainmentFrame should have exactly one child");
+
+  nsHTMLReflowMetrics childDesiredSize(aReflowState);
+
+  WritingMode wm = aReflowState.GetWritingMode();
+  nscoord iSize = aReflowState.AvailableISize();
+  LogicalSize availSize(wm, iSize, NS_UNCONSTRAINEDSIZE);
+
+  nsHTMLReflowState childReflowState(aPresContext, aReflowState,
+                                     child, availSize);
+
+  // The child should act as though it has no contents.
+  if (childReflowState.ComputedBSize() == NS_UNCONSTRAINEDSIZE) {
+    childReflowState.SetComputedBSize(0);
+  }
+
+  // XXX Whether or not we can actually have an inline child is not speced yet.
+  bool inlineChild = child->StyleDisplay()->IsInlineOutsideStyle();
+  if (inlineChild) {
+    childReflowState.SetComputedISize(0);
+  }
+
+  // Ignore child's margin.
+
+  nsReflowStatus childStatus;
+  nscoord containerWidth = aReflowState.ComputedWidth();
+
+  // Child is at offset (0, 0), since we are responsible for it's margin, and
+  // we have not border or padding.
+  ReflowChild(child, aPresContext, childDesiredSize,
+              childReflowState, wm, LogicalPoint(wm, 0, 0), containerWidth, 0,
+              childStatus);
+  MOZ_ASSERT(NS_FRAME_IS_FULLY_COMPLETE(childStatus),
+              "We gave our child unconstrained height, so it should be complete");
+
+  // Place the child
+  FinishReflowChild(child, aPresContext, childDesiredSize,
+                    &childReflowState, wm, LogicalPoint(wm, 0, 0),
+                    containerWidth, 0);
+
+  // XXX See above.
+  if (inlineChild) {
+    aMetrics.SetBlockStartAscent(child->GetLogicalBaseline(wm));
+  } else {
+    aMetrics.SetBlockStartAscent(0);
+  }
+
+  // XXX Why can't the following use childReflowState.ComputedSize(wm)?
+  aMetrics.SetSize(wm, childReflowState.ComputedLogicalBorderPadding().Size(wm));
+
+  aMetrics.SetOverflowAreasToDesiredBounds();
+
+  ConsiderChildOverflow(aMetrics.mOverflowAreas, child);
+
+  FinishAndStoreOverflow(&aMetrics);
+
+  aStatus = NS_FRAME_COMPLETE;
+
+  NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
+}
+
+#ifdef DEBUG_FRAME_DUMP
+nsresult
+nsContainmentFrame::GetFrameName(nsAString& aResult) const
+{
+  return MakeFrameName(NS_LITERAL_STRING("Containment"), aResult);
+}
+#endif
diff --git a/layout/generic/nsContainmentFrame.h b/layout/generic/nsContainmentFrame.h
new file mode 100644
--- /dev/null
+++ b/layout/generic/nsContainmentFrame.h
@@ -0,0 +1,35 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsContainmentFrame_h___
+#define nsContainmentFrame_h___
+
+//#include "mozilla/Attributes.h"
+#include "nsFrame.h"
+
+class nsContainmentFrame final : public nsContainerFrame {
+public:
+  NS_DECL_FRAMEARENA_HELPERS
+#ifdef DEBUG
+  NS_DECL_QUERYFRAME_TARGET(nsContainmentFrame)
+  NS_DECL_QUERYFRAME
+#endif
+
+  nsContainmentFrame(nsStyleContext* aContext)
+    : nsContainerFrame(aContext)
+  {
+  }
+
+  virtual void Reflow(nsPresContext* aPresContext,
+                      nsHTMLReflowMetrics& aDesiredSize,
+                      const nsHTMLReflowState& aReflowState,
+                      nsReflowStatus& aStatus) override;
+
+#ifdef DEBUG_FRAME_DUMP
+  virtual nsresult GetFrameName(nsAString& aResult) const override;
+#endif // DEBUG
+};
+
+#endif /* nsContainmentFrame_h___ */
diff --git a/layout/generic/nsFrameIdList.h b/layout/generic/nsFrameIdList.h
--- a/layout/generic/nsFrameIdList.h
+++ b/layout/generic/nsFrameIdList.h
@@ -11,16 +11,17 @@ FRAME_ID(nsBoxFrame)
 FRAME_ID(nsBulletFrame)
 FRAME_ID(nsButtonBoxFrame)
 FRAME_ID(nsCanvasFrame)
 FRAME_ID(nsColorControlFrame)
 FRAME_ID(nsColumnSetFrame)
 FRAME_ID(nsComboboxControlFrame)
 FRAME_ID(nsComboboxDisplayFrame)
 FRAME_ID(nsContainerFrame)
+FRAME_ID(nsContainmentFrame)
 FRAME_ID(nsContinuingTextFrame)
 FRAME_ID(nsDeckFrame)
 FRAME_ID(nsDocElementBoxFrame)
 FRAME_ID(nsFieldSetFrame)
 FRAME_ID(nsFileControlFrame)
 FRAME_ID(nsFirstLetterFrame)
 FRAME_ID(nsFirstLineFrame)
 FRAME_ID(nsFlexContainerFrame)
diff --git a/layout/generic/nsLineLayout.cpp b/layout/generic/nsLineLayout.cpp
--- a/layout/generic/nsLineLayout.cpp
+++ b/layout/generic/nsLineLayout.cpp
@@ -5,17 +5,16 @@
 
 /* state and methods used while laying out a single line of a block frame */
 
 // This has to be defined before nsLineLayout.h is included, because
 // nsLineLayout.h has a #include for plarena.h, which needs this defined:
 #define PL_ARENA_CONST_ALIGN_MASK (sizeof(void*)-1)
 #include "nsLineLayout.h"
 
-#include "LayoutLogging.h"
 #include "SVGTextFrame.h"
 #include "nsBlockFrame.h"
 #include "nsFontMetrics.h"
 #include "nsStyleConsts.h"
 #include "nsContainerFrame.h"
 #include "nsFloatManager.h"
 #include "nsStyleContext.h"
 #include "nsPresContext.h"
@@ -150,20 +149,20 @@ void
 nsLineLayout::BeginLineReflow(nscoord aICoord, nscoord aBCoord,
                               nscoord aISize, nscoord aBSize,
                               bool aImpactedByFloats,
                               bool aIsTopOfPage,
                               WritingMode aWritingMode,
                               const nsSize& aContainerSize)
 {
   NS_ASSERTION(nullptr == mRootSpan, "bad linelayout user");
-  LAYOUT_WARN_IF_FALSE(aISize != NS_UNCONSTRAINEDSIZE,
-                       "have unconstrained width; this should only result from "
-                       "very large sizes, not attempts at intrinsic width "
-                       "calculation");
+  NS_WARN_IF_FALSE(aISize != NS_UNCONSTRAINEDSIZE,
+                   "have unconstrained width; this should only result from "
+                   "very large sizes, not attempts at intrinsic width "
+                   "calculation");
 #ifdef DEBUG
   if ((aISize != NS_UNCONSTRAINEDSIZE) && CRAZY_SIZE(aISize)) {
     nsFrame::ListTag(stdout, mBlockReflowState->frame);
     printf(": Init: bad caller: width WAS %d(0x%x)\n",
            aISize, aISize);
   }
   if ((aBSize != NS_UNCONSTRAINEDSIZE) && CRAZY_SIZE(aBSize)) {
     nsFrame::ListTag(stdout, mBlockReflowState->frame);
@@ -874,20 +873,20 @@ nsLineLayout::ReflowFrame(nsIFrame* aFra
 
   // Figure out whether we're talking about a textframe here
   nsIAtom* frameType = aFrame->GetType();
   bool isText = frameType == nsGkAtoms::textFrame;
   
   // Inline-ish and text-ish things don't compute their width;
   // everything else does.  We need to give them an available width that
   // reflects the space left on the line.
-  LAYOUT_WARN_IF_FALSE(psd->mIEnd != NS_UNCONSTRAINEDSIZE,
-                      "have unconstrained width; this should only result from "
-                      "very large sizes, not attempts at intrinsic width "
-                      "calculation");
+  NS_WARN_IF_FALSE(psd->mIEnd != NS_UNCONSTRAINEDSIZE,
+                   "have unconstrained width; this should only result from "
+                   "very large sizes, not attempts at intrinsic width "
+                   "calculation");
   nscoord availableSpaceOnLine = psd->mIEnd - psd->mICoord;
 
   // Setup reflow state for reflowing the frame
   Maybe<nsHTMLReflowState> reflowStateHolder;
   if (!isText) {
     // Compute the available size for the frame. This available width
     // includes room for the side margins.
     // For now, set the available block-size to unconstrained always.
@@ -3048,20 +3047,20 @@ nsLineLayout::TextAlignLine(nsLineBox* a
                             bool aIsLastLine)
 {
   /**
    * NOTE: aIsLastLine ain't necessarily so: it is correctly set by caller
    * only in cases where the last line needs special handling.
    */
   PerSpanData* psd = mRootSpan;
   WritingMode lineWM = psd->mWritingMode;
-  LAYOUT_WARN_IF_FALSE(psd->mIEnd != NS_UNCONSTRAINEDSIZE,
-                       "have unconstrained width; this should only result from "
-                       "very large sizes, not attempts at intrinsic width "
-                       "calculation");
+  NS_WARN_IF_FALSE(psd->mIEnd != NS_UNCONSTRAINEDSIZE,
+                   "have unconstrained width; this should only result from "
+                   "very large sizes, not attempts at intrinsic width "
+                   "calculation");
   nscoord availISize = psd->mIEnd - psd->mIStart;
   nscoord remainingISize = availISize - aLine->ISize();
 #ifdef NOISY_INLINEDIR_ALIGN
   nsFrame::ListTag(stdout, mBlockReflowState->frame);
   printf(": availISize=%d lineBounds.IStart=%d lineISize=%d delta=%d\n",
          availISize, aLine->IStart(), aLine->ISize(), remainingISize);
 #endif
 
diff --git a/layout/reftests/css-contain/layout-zero.html b/layout/reftests/css-contain/layout-zero.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/css-contain/layout-zero.html
@@ -0,0 +1,37 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <meta charset="utf-8">
+  <style>
+  body {
+    margin: 0;
+  }
+  .container {
+    contain: layout;
+    background: red;
+    border: 1em solid green;
+    width: 100px;
+    //height: 100px;
+    //height: 0;
+  }
+  </style>
+</head>
+<body class="reftest-paint">
+  <div class="fun">
+    <div>
+      This is some content before the contained element.
+    </div>
+    <div>
+      This is a parent of the contained element.
+      <div class="container">
+        <div>
+    Lorem ipsum dolor sit amet, cu per agam quaerendum reprehendunt, scripta vivendo perfecto vis eu. Sea fastidii principes an. Sed in duis senserit, et cum impedit voluptaria, in nam sumo affert recteque. Sanctus suavitate voluptatibus te ius. Eos id insolens gloriatur repudiandae, vim in adhuc principes reprimique, vis ad omnium pericula reprimique.
+        </div>
+      </div>
+    </div>
+    <div>
+      This is some content after the contained element.
+    </div>
+  </div>
+</body>
+</html>
diff --git a/layout/style/nsCSSAnonBoxList.h b/layout/style/nsCSSAnonBoxList.h
--- a/layout/style/nsCSSAnonBoxList.h
+++ b/layout/style/nsCSSAnonBoxList.h
@@ -56,16 +56,17 @@ CSS_ANON_BOX(page, ":-moz-page")
 CSS_ANON_BOX(pageContent, ":-moz-pagecontent")
 CSS_ANON_BOX(pageSequence, ":-moz-page-sequence")
 CSS_ANON_BOX(scrolledContent, ":-moz-scrolled-content")
 CSS_ANON_BOX(scrolledCanvas, ":-moz-scrolled-canvas")
 CSS_ANON_BOX(scrolledPageSequence, ":-moz-scrolled-page-sequence")
 CSS_ANON_BOX(columnContent, ":-moz-column-content")
 CSS_ANON_BOX(viewport, ":-moz-viewport")
 CSS_ANON_BOX(viewportScroll, ":-moz-viewport-scroll")
+CSS_ANON_BOX(containment, ":-moz-containment")
 
 // Inside a flex container, a contiguous run of text gets wrapped in
 // an anonymous block, which is then treated as a flex item.
 CSS_ANON_BOX(anonymousFlexItem, ":-moz-anonymous-flex-item")
 
 // Inside a grid container, a contiguous run of text gets wrapped in
 // an anonymous block, which is then treated as a grid item.
 CSS_ANON_BOX(anonymousGridItem, ":-moz-anonymous-grid-item")
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -5707,17 +5707,17 @@ nsRuleNode::ComputeDisplayData(void* aSt
       EnsureBlockDisplay(display->mDisplay);
 
       // Note that it's OK to cache this struct in the ruletree
       // because it's fine as-is for any style context that points to
       // it directly, and any use of it as aStartStruct (e.g. if a
       // more specific rule sets "float: none") will use
       // mOriginalDisplay, which we have carefully not changed.
     }
-    if (display->IsPaintContaining()) {
+    if (display->IsPaintContaining() || display->IsLayoutContaining()) {
       // This is supposed to cause contain: paint and contain: layout elements
       // to become formatting contexts. However, exactly what formatting
       // context means has not been specificed yet.
       // Most likely, the intended behavior is similar to EnsureBlockDisplay.
       // XXX This will convert 'inline' to 'block' (instead of 'inline-block'). Is that right?
       EnsureBlockDisplay(display->mDisplay);
     }
   }
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -878,16 +878,34 @@ nsStyleSet::GetContext(nsStyleContext* a
 {
   NS_PRECONDITION((!aPseudoTag &&
                    aPseudoType ==
                      nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
                   (aPseudoTag &&
                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
                      aPseudoType),
                   "Pseudo mismatch");
+  if (!((!aPseudoTag &&
+                   aPseudoType ==
+                     nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
+                  (aPseudoTag &&
+                   nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
+                     aPseudoType))) {
+    NS_ASSERTION(aPseudoTag, "");
+    NS_ASSERTION((!aPseudoTag &&
+                    aPseudoType ==
+                      nsCSSPseudoElements::ePseudo_NotPseudoElement), "");
+    NS_ASSERTION((aPseudoTag &&
+                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
+                      aPseudoType), "");
+    NS_ASSERTION(aPseudoTag == nsCSSAnonBoxes::containment, "");
+    printf("aPseudoTag = %p\n", aPseudoTag);
+    printf("nsCSSPseudoElements::GetPseudoType(aPseudoTag) = %d\n", nsCSSPseudoElements::GetPseudoType(aPseudoTag));
+    printf("aPseudoType = %d\n", aPseudoType);
+  }
 
   if (aVisitedRuleNode == aRuleNode) {
     // No need to force creation of a visited style in this case.
     aVisitedRuleNode = nullptr;
   }
 
   // Ensure |aVisitedRuleNode != nullptr| corresponds to the need to
   // create an if-visited style context, and that in that case, we have
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -2244,16 +2244,20 @@ struct nsStyleDisplay {
 
   bool IsScrollableOverflow() const {
     // mOverflowX and mOverflowY always match when one of them is
     // NS_STYLE_OVERFLOW_VISIBLE or NS_STYLE_OVERFLOW_CLIP.
     return mOverflowX != NS_STYLE_OVERFLOW_VISIBLE &&
            mOverflowX != NS_STYLE_OVERFLOW_CLIP;
   }
 
+  bool IsLayoutContaining() const {
+    return NS_STYLE_CONTAIN_LAYOUT & mContain;
+  }
+
   bool IsStyleContaining() const {
     return NS_STYLE_CONTAIN_STYLE & mContain;
   }
 
   bool IsPaintContaining() const {
     return mContain & NS_STYLE_CONTAIN_PAINT;
   }
 
diff --git a/layout/style/ua.css b/layout/style/ua.css
--- a/layout/style/ua.css
+++ b/layout/style/ua.css
@@ -519,8 +519,16 @@ div:-moz-native-anonymous.moz-custom-con
   position: fixed;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
 
   z-index: 2147483648;
 }
+
+*|*::-moz-containment {
+  /* Do to the strange way containment frames are created, this actually
+   * inherits from the *child* of the containment frame.
+   * See BuildContainment() in nsCSSFrameConstructor.cpp for details.
+   */
+  display: inherit;
+}
