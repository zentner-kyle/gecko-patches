# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  9190d6cfa4ce65fae51e98bdb8c93260b421b5f1
Bug 1178895 - Patch 2: Implement 'contain: layout' for nsBlockFrame.

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -671,16 +671,24 @@ nsBlockFrame::GetMinISize(nsRenderingCon
   nsIFrame* firstInFlow = FirstContinuation();
   if (firstInFlow != this)
     return firstInFlow->GetMinISize(aRenderingContext);
 
   DISPLAY_MIN_WIDTH(this, mMinWidth);
 
   CheckIntrinsicCacheAgainstShrinkWrapState();
 
+  if (StyleDisplay()->IsContainLayout()) {
+    if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN) {
+      return mMinWidth;
+    } else {
+      return 0;
+    }
+  }
+
   if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
     return mMinWidth;
 
 #ifdef DEBUG
   if (gNoisyIntrinsic) {
     IndentBy(stdout, gNoiseIndent);
     ListTag(stdout);
     printf(": GetMinISize\n");
@@ -756,16 +764,25 @@ nsBlockFrame::GetPrefISize(nsRenderingCo
   nsIFrame* firstInFlow = FirstContinuation();
   if (firstInFlow != this)
     return firstInFlow->GetPrefISize(aRenderingContext);
 
   DISPLAY_PREF_WIDTH(this, mPrefWidth);
 
   CheckIntrinsicCacheAgainstShrinkWrapState();
 
+  if (StyleDisplay()->IsContainLayout()) {
+    if (mPrefWidth != NS_INTRINSIC_WIDTH_UNKNOWN) {
+      return mPrefWidth;
+    } else {
+      return 0;
+    }
+  }
+
+
   if (mPrefWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
     return mPrefWidth;
 
 #ifdef DEBUG
   if (gNoisyIntrinsic) {
     IndentBy(stdout, gNoiseIndent);
     ListTag(stdout);
     printf(": GetPrefISize\n");
@@ -1494,16 +1511,20 @@ nsBlockFrame::ComputeFinalSize(const nsH
       aState.mPrevBEndMargin.Zero();
     }
     aMetrics.mCarriedOutBEndMargin = aState.mPrevBEndMargin;
   } else {
     aMetrics.mCarriedOutBEndMargin.Zero();
   }
 
   nscoord blockEndEdgeOfChildren = aState.mBCoord + nonCarriedOutBDirMargin;
+  if (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedBSize() &&
+      StyleDisplay()->IsContainLayout()) {
+    blockEndEdgeOfChildren = 0;
+  }
   // Shrink wrap our height around our contents.
   if (aState.GetFlag(BRS_ISBENDMARGINROOT) ||
       NS_UNCONSTRAINEDSIZE != aReflowState.ComputedBSize()) {
     // When we are a block-end-margin root make sure that our last
     // childs block-end margin is fully applied. We also do this when
     // we have a computed height, since in that case the carried out
     // margin is not going to be applied anywhere, so we should note it
     // here to be included in the overflow area.
@@ -1517,17 +1538,19 @@ nsBlockFrame::ComputeFinalSize(const nsH
     }
   }
   if (aState.GetFlag(BRS_FLOAT_MGR)) {
     // Include the float manager's state to properly account for the
     // block-end margin of any floated elements; e.g., inside a table cell.
     nscoord floatHeight =
       aState.ClearFloats(blockEndEdgeOfChildren, NS_STYLE_CLEAR_BOTH,
                          nullptr, nsFloatManager::DONT_CLEAR_PUSHED_FLOATS);
-    blockEndEdgeOfChildren = std::max(blockEndEdgeOfChildren, floatHeight);
+    if (!StyleDisplay()->IsContainLayout()) {
+      blockEndEdgeOfChildren = std::max(blockEndEdgeOfChildren, floatHeight);
+    }
   }
 
   if (NS_UNCONSTRAINEDSIZE != aReflowState.ComputedBSize()
       && (GetParent()->GetType() != nsGkAtoms::columnSetFrame ||
           aReflowState.parentReflowState->AvailableBSize() == NS_UNCONSTRAINEDSIZE)) {
     ComputeFinalBSize(aReflowState, &aState.mReflowStatus,
                       aState.mBCoord + nonCarriedOutBDirMargin,
                       borderPadding, finalSize, aState.mConsumedBSize);
