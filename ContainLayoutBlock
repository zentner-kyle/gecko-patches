# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  d138e0766f91c0463c55597d45373df308bc6056
Bug 1178895 - Patch 2: Implement 'contain: layout' for nsBlockFrame.

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -671,16 +671,24 @@ nsBlockFrame::GetMinISize(nsRenderingCon
   nsIFrame* firstInFlow = FirstContinuation();
   if (firstInFlow != this)
     return firstInFlow->GetMinISize(aRenderingContext);
 
   DISPLAY_MIN_WIDTH(this, mMinWidth);
 
   CheckIntrinsicCacheAgainstShrinkWrapState();
 
+  if (StyleDisplay()->IsContainLayout()) {
+    if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN) {
+      return mMinWidth;
+    } else {
+      return 0;
+    }
+  }
+
   if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
     return mMinWidth;
 
 #ifdef DEBUG
   if (gNoisyIntrinsic) {
     IndentBy(stdout, gNoiseIndent);
     ListTag(stdout);
     printf(": GetMinISize\n");
@@ -756,16 +764,25 @@ nsBlockFrame::GetPrefISize(nsRenderingCo
   nsIFrame* firstInFlow = FirstContinuation();
   if (firstInFlow != this)
     return firstInFlow->GetPrefISize(aRenderingContext);
 
   DISPLAY_PREF_WIDTH(this, mPrefWidth);
 
   CheckIntrinsicCacheAgainstShrinkWrapState();
 
+  if (StyleDisplay()->IsContainLayout()) {
+    if (mPrefWidth != NS_INTRINSIC_WIDTH_UNKNOWN) {
+      return mPrefWidth;
+    } else {
+      return 0;
+    }
+  }
+
+
   if (mPrefWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
     return mPrefWidth;
 
 #ifdef DEBUG
   if (gNoisyIntrinsic) {
     IndentBy(stdout, gNoiseIndent);
     ListTag(stdout);
     printf(": GetPrefISize\n");
@@ -1494,16 +1511,23 @@ nsBlockFrame::ComputeFinalSize(const nsH
       aState.mPrevBEndMargin.Zero();
     }
     aMetrics.mCarriedOutBEndMargin = aState.mPrevBEndMargin;
   } else {
     aMetrics.mCarriedOutBEndMargin.Zero();
   }
 
   nscoord blockEndEdgeOfChildren = aState.mBCoord + nonCarriedOutBDirMargin;
+  if (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedBSize() &&
+      StyleDisplay()->IsContainLayout()) {
+    // If we don't have a specified size, and we're layout contained, we should
+    // pretend our children don't exist (have zero block size) when calculating
+    // our own size.
+    blockEndEdgeOfChildren = 0;
+  }
   // Shrink wrap our height around our contents.
   if (aState.GetFlag(BRS_ISBENDMARGINROOT) ||
       NS_UNCONSTRAINEDSIZE != aReflowState.ComputedBSize()) {
     // When we are a block-end-margin root make sure that our last
     // childs block-end margin is fully applied. We also do this when
     // we have a computed height, since in that case the carried out
     // margin is not going to be applied anywhere, so we should note it
     // here to be included in the overflow area.
@@ -1511,17 +1535,17 @@ nsBlockFrame::ComputeFinalSize(const nsH
     if (blockEndEdgeOfChildren < aState.mReflowState.AvailableBSize())
     {
       // Truncate block-end margin if it doesn't fit to our available BSize.
       blockEndEdgeOfChildren =
         std::min(blockEndEdgeOfChildren + aState.mPrevBEndMargin.get(),
                aState.mReflowState.AvailableBSize());
     }
   }
-  if (aState.GetFlag(BRS_FLOAT_MGR)) {
+  if (aState.GetFlag(BRS_FLOAT_MGR) && !StyleDisplay()->IsContainLayout()) {
     // Include the float manager's state to properly account for the
     // block-end margin of any floated elements; e.g., inside a table cell.
     nscoord floatHeight =
       aState.ClearFloats(blockEndEdgeOfChildren, NS_STYLE_CLEAR_BOTH,
                          nullptr, nsFloatManager::DONT_CLEAR_PUSHED_FLOATS);
     blockEndEdgeOfChildren = std::max(blockEndEdgeOfChildren, floatHeight);
   }
 
