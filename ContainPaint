# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  291614a686f1402b08db75699a8aa4c487d0f17f
Bug 1170781 - Patch 1: Implement CSS 'contain: paint'.

diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -6642,18 +6642,21 @@ nsBlockFrame::Init(nsIContent*       aCo
     AddStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
   }
 
   // If a box has a different block flow direction than its containing block:
   // ...
   //   If the box is a block container, then it establishes a new block
   //   formatting context.
   // (http://dev.w3.org/csswg/css-writing-modes/#block-flow)
-  if (GetParent() && StyleVisibility()->mWritingMode !=
-                     GetParent()->StyleVisibility()->mWritingMode) {
+  // If the box has contain: paint (or contain: strict), then it should also
+  // establish a fromatting context.
+  if ((GetParent() && StyleVisibility()->mWritingMode !=
+                     GetParent()->StyleVisibility()->mWritingMode) ||
+      StyleDisplay()->IsPaintContaining()) {
     AddStateBits(NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
   }
 
   if ((GetStateBits() &
        (NS_FRAME_FONT_INFLATION_CONTAINER | NS_BLOCK_FLOAT_MGR)) ==
       (NS_FRAME_FONT_INFLATION_CONTAINER | NS_BLOCK_FLOAT_MGR)) {
     AddStateBits(NS_FRAME_FONT_INFLATION_FLOW_ROOT);
   }
diff --git a/layout/generic/nsFrame.cpp b/layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp
+++ b/layout/generic/nsFrame.cpp
@@ -2382,36 +2382,54 @@ nsIFrame::BuildDisplayListForChild(nsDis
     // If you change this, also change IsPseudoStackingContextFromStyle()
     pseudoStackingContext = true;
   }
   NS_ASSERTION(!isStackingContext || pseudoStackingContext,
                "Stacking contexts must also be pseudo-stacking-contexts");
 
   nsDisplayListBuilder::AutoBuildingDisplayList
     buildingForChild(aBuilder, child, dirty, pseudoStackingContext);
-  DisplayListClipState::AutoClipMultiple clipState(aBuilder);
+
+  Maybe<DisplayListClipState::AutoClipMultiple> clipState;
+  Maybe<DisplayListClipState::AutoSaveRestore> containClipState;
+  DisplayListClipState::AutoSaveRestore *usedClipState = nullptr;
+  if (ourDisp->IsPaintContaining()) {
+    // If we're 'contain: paint', clip *all* of our descendants.
+    containClipState.emplace(aBuilder);
+    nsRect contentRect = GetContentRectRelativeToSelf() +
+      aBuilder->ToReferenceFrame(this);
+    nscoord radii[8];
+    GetContentBoxBorderRadii(radii);
+    containClipState->ClipContentDescendants(contentRect, radii);
+    usedClipState = &containClipState;
+  } else {
+    // Otherwise, just clip the block descendants.
+    clipState.emplace(aBuilder);
+    usedClipState = &clipState;
+  }
+
   CheckForApzAwareEventHandlers(aBuilder, child);
 
   if (savedOutOfFlowData) {
-    clipState.SetClipForContainingBlockDescendants(
+    usedClipState->SetClipForContainingBlockDescendants(
       &savedOutOfFlowData->mContainingBlockClip);
   }
 
   // Setup clipping for the parent's overflow:-moz-hidden-unscrollable,
   // or overflow:hidden on elements that don't support scrolling (and therefore
   // don't create nsHTML/XULScrollFrame). This clipping needs to not clip
   // anything directly rendered by the parent, only the rendering of its
   // children.
   // Don't use overflowClip to restrict the dirty rect, since some of the
   // descendants may not be clipped by it. Even if we end up with unnecessary
   // display items, they'll be pruned during ComputeVisibility.
   nsIFrame* parent = child->GetParent();
   const nsStyleDisplay* parentDisp =
     parent == this ? ourDisp : parent->StyleDisplay();
-  ApplyOverflowClipping(aBuilder, parent, parentDisp, clipState);
+  ApplyOverflowClipping(aBuilder, parent, parentDisp, usedClipState);
 
   nsDisplayList list;
   nsDisplayList extraPositionedDescendants;
   if (isStackingContext) {
     if (disp->mMixBlendMode != NS_STYLE_BLEND_NORMAL) {
       aBuilder->SetContainsBlendMode(disp->mMixBlendMode);
     }
     // True stacking context.
diff --git a/layout/style/nsRuleNode.cpp b/layout/style/nsRuleNode.cpp
--- a/layout/style/nsRuleNode.cpp
+++ b/layout/style/nsRuleNode.cpp
@@ -5707,17 +5707,24 @@ nsRuleNode::ComputeDisplayData(void* aSt
       EnsureBlockDisplay(display->mDisplay);
 
       // Note that it's OK to cache this struct in the ruletree
       // because it's fine as-is for any style context that points to
       // it directly, and any use of it as aStartStruct (e.g. if a
       // more specific rule sets "float: none") will use
       // mOriginalDisplay, which we have carefully not changed.
     }
-
+    if (display->IsPaintContaining()) {
+      // This is supposed to cause contain: paint and contain: layout elements
+      // to become formatting contexts. However, exactly what formatting
+      // context means has not been specificed yet.
+      // Most likely, the intended behavior is similar to EnsureBlockDisplay.
+      // XXX This will convert 'inline' to 'block' (instead of 'inline-block'). Is that right?
+      EnsureBlockDisplay(display->mDisplay);
+    }
   }
 
   /* Convert the nsCSSValueList into an nsTArray<nsTransformFunction *>. */
   const nsCSSValue* transformValue = aRuleData->ValueForTransform();
   switch (transformValue->GetUnit()) {
   case eCSSUnit_Null:
     break;
 
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -2244,16 +2244,20 @@ struct nsStyleDisplay {
 
   bool IsScrollableOverflow() const {
     // mOverflowX and mOverflowY always match when one of them is
     // NS_STYLE_OVERFLOW_VISIBLE or NS_STYLE_OVERFLOW_CLIP.
     return mOverflowX != NS_STYLE_OVERFLOW_VISIBLE &&
            mOverflowX != NS_STYLE_OVERFLOW_CLIP;
   }
 
+  bool IsPaintContaining() const {
+    return mContain & NS_STYLE_CONTAIN_PAINT;
+  }
+
   /* Returns whether the element has the -moz-transform property
    * or a related property. */
   bool HasTransformStyle() const {
     return mSpecifiedTransform != nullptr ||
            mTransformStyle == NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D ||
            (mWillChangeBitField & NS_STYLE_WILL_CHANGE_TRANSFORM);
   }
 
diff --git a/layout/style/nsStyleStructInlines.h b/layout/style/nsStyleStructInlines.h
--- a/layout/style/nsStyleStructInlines.h
+++ b/layout/style/nsStyleStructInlines.h
@@ -133,19 +133,19 @@ nsStyleDisplay::HasTransform(const nsIFr
 {
   NS_ASSERTION(aContextFrame->StyleDisplay() == this, "unexpected aContextFrame");
   return HasTransformStyle() && aContextFrame->IsFrameOfType(nsIFrame::eSupportsCSSTransforms);
 }
 
 bool
 nsStyleDisplay::IsFixedPosContainingBlock(const nsIFrame* aContextFrame) const
 {
-  return (HasTransform(aContextFrame) || HasPerspectiveStyle() ||
+  return ((HasTransform(aContextFrame) || HasPerspectiveStyle() ||
           !aContextFrame->StyleSVGReset()->mFilters.IsEmpty()) &&
-      !aContextFrame->IsSVGText();
+      !aContextFrame->IsSVGText()) || IsPaintContaining();
 }
 
 bool
 nsStyleDisplay::IsAbsPosContainingBlock(const nsIFrame* aContextFrame) const
 {
   NS_ASSERTION(aContextFrame->StyleDisplay() == this,
                "unexpected aContextFrame");
   return ((IsAbsolutelyPositionedStyle() || IsRelativelyPositionedStyle()) &&
