# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  d9bee8b6b5e14ab1ff4071167c569dbadae07414
Bug 1178895 - Patch 6: Implement 'contain: layout' for flexbox.

diff --git a/layout/generic/nsFlexContainerFrame.cpp b/layout/generic/nsFlexContainerFrame.cpp
--- a/layout/generic/nsFlexContainerFrame.cpp
+++ b/layout/generic/nsFlexContainerFrame.cpp
@@ -3354,16 +3354,18 @@ nsFlexContainerFrame::ComputeCrossSize(c
     // XXXdholbert For now, we don't support pushing children to our next
     // continuation or splitting children, so "amount of BSize required by
     // our children" is just the sum of our FlexLines' BSizes (cross sizes).
     NS_FRAME_SET_INCOMPLETE(aStatus);
     if (aSumLineCrossSizes <= aAvailableBSizeForContent) {
       return aAvailableBSizeForContent;
     }
     return std::min(effectiveComputedBSize, aSumLineCrossSizes);
+  } else if (nsLayoutUtils::IsContainLayout(this)) {
+    return 0;
   }
 
   // Row-oriented case (cross axis is block axis), with auto BSize:
   // Shrink-wrap our line(s), subject to our min-size / max-size
   // constraints in that (block) axis.
   // XXXdholbert Handle constrained-aAvailableBSizeForContent case here.
   *aIsDefinite = false;
   return NS_CSS_MINMAX(aSumLineCrossSizes,
@@ -4083,16 +4085,20 @@ nsFlexContainerFrame::ReflowFlexItem(nsP
 }
 
 /* virtual */ nscoord
 nsFlexContainerFrame::GetMinISize(nsRenderingContext* aRenderingContext)
 {
   nscoord minWidth = 0;
   DISPLAY_MIN_WIDTH(this, minWidth);
 
+  if (nsLayoutUtils::IsContainLayout(this)) {
+    return minWidth;
+  }
+
   const nsStylePosition* stylePos = StylePosition();
   const FlexboxAxisTracker axisTracker(stylePos, GetWritingMode());
 
   for (nsIFrame* childFrame : mFrames) {
     nscoord childMinWidth =
       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, childFrame,
                                            nsLayoutUtils::MIN_ISIZE);
     // For a horizontal single-line flex container, the intrinsic min width is
@@ -4110,16 +4116,20 @@ nsFlexContainerFrame::GetMinISize(nsRend
 }
 
 /* virtual */ nscoord
 nsFlexContainerFrame::GetPrefISize(nsRenderingContext* aRenderingContext)
 {
   nscoord prefWidth = 0;
   DISPLAY_PREF_WIDTH(this, prefWidth);
 
+  if (nsLayoutUtils::IsContainLayout(this)) {
+    return prefWidth;
+  }
+
   // XXXdholbert Optimization: We could cache our intrinsic widths like
   // nsBlockFrame does (and return it early from this function if it's set).
   // Whenever anything happens that might change it, set it to
   // NS_INTRINSIC_WIDTH_UNKNOWN (like nsBlockFrame::MarkIntrinsicISizesDirty
   // does)
   const FlexboxAxisTracker axisTracker(StylePosition(), GetWritingMode());
 
   for (nsIFrame* childFrame : mFrames) {
