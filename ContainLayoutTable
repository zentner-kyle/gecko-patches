# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  751b4da609673786b03ab2bdcdebf62c70158585
Bug 1178895 - Patch 4: Implement 'contain: layout' for table elements.

diff --git a/layout/reftests/w3c-css/submitted/contain/contain-layout-table-001.html b/layout/reftests/w3c-css/submitted/contain/contain-layout-table-001.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/w3c-css/submitted/contain/contain-layout-table-001.html
@@ -0,0 +1,227 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <meta charset="utf-8">
+  <title>CSS Test: 'contain: layout' on block element containing
+    floats should cause the element to have zero height.</title>
+  <link rel="author" title="Kyle Zentner" href="mailto:kzentner@mozilla.com">
+  <link rel="help" href="http://www.w3.org/TR/css-containment-1/#containment-layout">
+  <link rel="match" href="contain-layout-block-003-ref.html">
+  <style>
+  body {
+    margin: 0;
+  }
+  .container {
+    contain: layout;
+    border: 1em solid black;
+    background: cyan;
+  }
+  .right-float {
+    float: right;
+    background: blue;
+    width: 20px;
+    height: 20px;
+    margin: 20px;
+  }
+  .left-float {
+    float: left;
+    background: orange;
+    width: 20px;
+    height: 20px;
+    margin: 20px;
+  }
+  table {
+    margin: 100px;
+    border: solid black 3px;
+    background: blue;
+    padding: 3px;
+  }
+  td {
+    margin: 5px;
+    border: solid black 10px;
+    padding: 3px;
+  }
+  tbody {
+    padding: 3px;
+    background: pink;
+  }
+  tr {
+    padding: 5px;
+    background: orange;
+  }
+  thead td {
+    background: pink;
+  }
+  tbody td {
+    background: green;
+  }
+  tfoot td {
+    background: purple;
+  }
+  .big-block {
+    width: 100px;
+    height: 100px;
+    background: salmon;
+  }
+  .block {
+    display: inline-block;
+    width: 50px;
+    height: 50px;
+    background: teal;
+  }
+  td {
+    //border: 1em solid black;
+  }
+  table {
+    table-layout: fixed;
+  }
+  </style>
+</head>
+<body class="reftest-paint">
+  <table>
+    <thead>
+      <tr>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+      </tr>
+      <tr>
+        <td>Table begin. Things thing sthings things things. Words words words words. Words words words words words words.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+          <div class="block"></div>
+        </td>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+      </tr>
+      <tr>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="big-block"></div>
+          <div class="block"></div>
+        </td>
+      </tr>
+    </thead>
+    <tbody>
+      <tr>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+      </tr>
+      <tr>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+      </tr>
+    </tbody>
+    <tfoot>
+      <tr>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+      </tr>
+      <tr>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+        <td>
+          Table begin.
+          <div class="right-float"></div>
+          Table table.
+          <div class="left-float"></div>
+          Table end.
+          <div class="block"></div>
+        </td>
+      </tr>
+    </tfoot>
+  </table>
+</body>
+</html>
diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -444,16 +444,19 @@ BasicTableLayoutStrategy::ComputeIntrins
     ComputeColumnIntrinsicISizes(aRenderingContext);
 
     nsTableCellMap *cellMap = mTableFrame->GetCellMap();
     nscoord min = 0, pref = 0, max_small_pct_pref = 0, nonpct_pref_total = 0;
     float pct_total = 0.0f; // always from 0.0f - 1.0f
     int32_t colCount = cellMap->GetColCount();
     // add a total of (colcount + 1) lots of cellSpacingX for columns where a
     // cell originates
+    if (mTableFrame->StyleDisplay()->IsContainLayout()) {
+        colCount = 0;
+    }
     nscoord add = mTableFrame->GetColSpacing(colCount);
 
     for (int32_t col = 0; col < colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -29,16 +29,19 @@ FixedTableLayoutStrategy::~FixedTableLay
 
 /* virtual */ nscoord
 FixedTableLayoutStrategy::GetMinISize(nsRenderingContext* aRenderingContext)
 {
   DISPLAY_MIN_WIDTH(mTableFrame, mMinISize);
   if (mMinISize != NS_INTRINSIC_WIDTH_UNKNOWN) {
     return mMinISize;
   }
+  if (mTableFrame->StyleDisplay()->IsContainLayout()) {
+    return (mMinISize = 0);
+  }
 
   // It's theoretically possible to do something much better here that
   // depends only on the columns and the first row (where we look at
   // intrinsic inline sizes inside the first row and then reverse the
   // algorithm to find the narrowest inline size that would hold all of
   // those intrinsic inline sizes), but it wouldn't be compatible with
   // other browsers, or with the use of GetMinISize by
   // nsTableFrame::ComputeSize to determine the inline size of a fixed
diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -623,17 +623,17 @@ void nsTableCellFrame::BlockDirAlignChil
     break;
 
     default:
     case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
       // Align the middle of the child frame with the middle of the content area,
       kidBStart = (bSize - childBSize - bEndInset + bStartInset) / 2;
   }
   // if the content is larger than the cell bsize, align from bstart
-  kidBStart = std::max(0, kidBStart);
+  kidBStart = std::max(bStartInset, kidBStart);
 
   if (kidBStart != kidRect.BStart(aWM)) {
     // Invalidate at the old position first
     firstKid->InvalidateFrameSubtree();
   }
 
   firstKid->SetPosition(aWM, LogicalPoint(aWM, kidRect.IStart(aWM),
                                           kidBStart), containerSize);
@@ -769,28 +769,36 @@ int32_t nsTableCellFrame::GetColSpan()
 }
 
 /* virtual */ nscoord
 nsTableCellFrame::GetMinISize(nsRenderingContext *aRenderingContext)
 {
   nscoord result = 0;
   DISPLAY_MIN_WIDTH(this, result);
 
+  if (StyleDisplay()->IsContainLayout()) {
+    return result;
+  }
+
   nsIFrame *inner = mFrames.FirstChild();
   result = nsLayoutUtils::IntrinsicForContainer(aRenderingContext, inner,
                                                     nsLayoutUtils::MIN_ISIZE);
   return result;
 }
 
 /* virtual */ nscoord
 nsTableCellFrame::GetPrefISize(nsRenderingContext *aRenderingContext)
 {
   nscoord result = 0;
   DISPLAY_PREF_WIDTH(this, result);
 
+  if (StyleDisplay()->IsContainLayout()) {
+    return result;
+  }
+
   nsIFrame *inner = mFrames.FirstChild();
   result = nsLayoutUtils::IntrinsicForContainer(aRenderingContext, inner,
                                                 nsLayoutUtils::PREF_ISIZE);
   return result;
 }
 
 /* virtual */ nsIFrame::IntrinsicISizeOffsetData
 nsTableCellFrame::IntrinsicISizeOffsets()
@@ -975,37 +983,38 @@ nsTableCellFrame::Reflow(nsPresContext* 
   // see testcase "emptyCells.html"
   nsIFrame* prevInFlow = GetPrevInFlow();
   bool isEmpty;
   if (prevInFlow) {
     isEmpty = static_cast<nsTableCellFrame*>(prevInFlow)->GetContentEmpty();
   } else {
     isEmpty = !CellHasVisibleContent(kidSize.Height(), tableFrame, firstKid);
   }
+
   SetContentEmpty(isEmpty);
 
   // Place the child
   FinishReflowChild(firstKid, aPresContext, kidSize, &kidReflowState,
                     wm, kidOrigin, containerSize, 0);
 
   nsTableFrame::InvalidateTableFrame(firstKid, origRect, origVisualOverflow,
                                      firstReflow);
 
   // first, compute the bsize which can be set w/o being restricted by
   // available bsize
   LogicalSize cellSize(wm);
-  cellSize.BSize(wm) = kidSize.BSize(wm);
+  if (!StyleDisplay()->IsContainLayout()) {
+    cellSize.BSize(wm) = kidSize.BSize(wm);
+    cellSize.ISize(wm) = kidSize.ISize(wm);
+  }
 
   if (NS_UNCONSTRAINEDSIZE != cellSize.BSize(wm)) {
     cellSize.BSize(wm) += borderPadding.BStartEnd(wm);
   }
 
-  // next determine the cell's isize
-  cellSize.ISize(wm) = kidSize.ISize(wm);      // at this point, we've factored in the cell's style attributes
-
   // factor in border and padding
   if (NS_UNCONSTRAINEDSIZE != cellSize.ISize(wm)) {
     cellSize.ISize(wm) += borderPadding.IStartEnd(wm);
   }
 
   // set the cell's desired size and max element size
   aDesiredSize.SetSize(wm, cellSize);
 
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -3295,17 +3295,17 @@ nsTableFrame::CalcDesiredBSize(const nsH
     aDesiredSize.BSize(wm) = 0;
     return;
   }
   LogicalMargin borderPadding = GetChildAreaOffset(wm, &aReflowState);
 
   // get the natural bsize based on the last child's (row group) rect
   RowGroupArray rowGroups;
   OrderRowGroups(rowGroups);
-  if (rowGroups.IsEmpty()) {
+  if (StyleDisplay()->IsContainLayout() || rowGroups.IsEmpty()) {
     // tables can be used as rectangular items without content
     nscoord tableSpecifiedBSize = CalcBorderBoxBSize(aReflowState);
     if ((NS_UNCONSTRAINEDSIZE != tableSpecifiedBSize) &&
         (tableSpecifiedBSize > 0) &&
         eCompatibility_NavQuirks != PresContext()->CompatibilityMode()) {
           // empty tables should not have a size in quirks mode
       aDesiredSize.BSize(wm) = tableSpecifiedBSize;
     } else {
@@ -3667,16 +3667,21 @@ nsTableFrame::DistributeBSizeToRows(cons
   ResizeCells(*this);
 }
 
 nscoord
 nsTableFrame::GetColumnISizeFromFirstInFlow(int32_t aColIndex)
 {
   MOZ_ASSERT(this == FirstInFlow());
   nsTableColFrame* colFrame = GetColFrame(aColIndex);
+  // TODO kzentner: Do we need to do this?
+  //nsTableColFrame* colFrame = nullptr;
+  //if (!StyleDisplay()->IsContainLayout()) {
+    //colFrame = GetColFrame(aColIndex);
+  //}
   return colFrame ? colFrame->GetFinalISize() : 0;
 }
 
 nscoord
 nsTableFrame::GetColSpacing()
 {
   if (IsBorderCollapse())
     return 0;
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -1109,18 +1109,23 @@ nsTableRowFrame::Reflow(nsPresContext*  
   }
 
   // see if a special bsize reflow needs to occur due to having a pct bsize
   nsTableFrame::CheckRequestSpecialBSizeReflow(aReflowState);
 
   // See if we have a cell with specified/pct bsize
   InitHasCellWithStyleBSize(tableFrame);
 
+  nscoord emptyBSize = aDesiredSize.BSize(wm);
   ReflowChildren(aPresContext, aDesiredSize, aReflowState, *tableFrame, aStatus);
 
+  if (StyleDisplay()->IsContainLayout()) {
+    aDesiredSize.BSize(wm) = emptyBSize;
+  }
+
   if (aPresContext->IsPaginated() && !NS_FRAME_IS_FULLY_COMPLETE(aStatus) &&
       ShouldAvoidBreakInside(aReflowState)) {
     aStatus = NS_INLINE_LINE_BREAK_BEFORE();
   }
 
   // Just set our isize to what was available.
   // The table will calculate the isize and not use our value.
   aDesiredSize.ISize(wm) = aReflowState.AvailableISize();
diff --git a/layout/tables/nsTableRowGroupFrame.cpp b/layout/tables/nsTableRowGroupFrame.cpp
--- a/layout/tables/nsTableRowGroupFrame.cpp
+++ b/layout/tables/nsTableRowGroupFrame.cpp
@@ -452,19 +452,21 @@ nsTableRowGroupFrame::ReflowChildren(nsP
     ConsiderChildOverflow(aDesiredSize.mOverflowAreas, kidFrame);
   }
 
   if (haveRow) {
     aReflowState.bCoord -= tableFrame->GetRowSpacing(GetStartRowIndex() +
                                                      GetRowCount());
   }
 
-  // Return our desired rect
-  aDesiredSize.ISize(wm) = aReflowState.reflowState.AvailableISize();
-  aDesiredSize.BSize(wm) = aReflowState.bCoord;
+  if (!StyleDisplay()->IsContainPaint()) {
+    // Return our desired rect
+    aDesiredSize.ISize(wm) = aReflowState.reflowState.AvailableISize();
+    aDesiredSize.BSize(wm) = aReflowState.bCoord;
+  }
 
   if (aReflowState.reflowState.mFlags.mSpecialBSizeReflow) {
     DidResizeRows(aDesiredSize);
     if (isPaginated) {
       CacheRowBSizesForPrinting(aPresContext, GetFirstRow(), wm);
     }
   }
   else if (needToCalcRowBSizes) {
