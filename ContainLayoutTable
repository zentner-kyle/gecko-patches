# HG changeset patch
# User Kyle Zentner <kzentner@mozilla.com>
# Parent  bcb96d97a18c4c80f0b4517125388f3cf8eaf2fd

diff --git a/layout/reftests/w3c-css/submitted/contain/contain-layout-table-001.html b/layout/reftests/w3c-css/submitted/contain/contain-layout-table-001.html
new file mode 100644
--- /dev/null
+++ b/layout/reftests/w3c-css/submitted/contain/contain-layout-table-001.html
@@ -0,0 +1,28 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+  <meta charset="utf-8">
+  <title>CSS Test: 'contain: layout' on tr in table
+    to become a block with zero height.</title>
+  <link rel="author" title="Kyle Zentner" href="mailto:kzentner@mozilla.com">
+  <link rel="help" href="http://www.w3.org/TR/css-containment-1/#containment-layout">
+  <link rel="match" href="FIXME.html">
+  <style>
+  body {
+    margin: 0;
+  }
+  .container {
+    contain: layout;
+    background: red;
+    border: 1em solid green;
+  }
+  </style>
+</head>
+<body>
+  <table class="container">
+    <tr>
+      Lorem ipsum dolor sit amet
+    </tr>
+  </table>
+</body>
+</html>
diff --git a/layout/style/test/test_contain_layout_empty.html b/layout/style/test/test_contain_layout_empty.html
--- a/layout/style/test/test_contain_layout_empty.html
+++ b/layout/style/test/test_contain_layout_empty.html
@@ -92,18 +92,21 @@ https://bugzilla.mozilla.org/show_bug.cg
 
       var fakeSnapshot = SpecialPowers.snapshotWindow(window);
       assertSnapshots(realSnapshot, fakeSnapshot, true, null,
       outerDisplay + " / " + innerDisplay + " contain: layout", "faked contain:layout");
       outerElem.parentNode.removeChild(outerElem);
       innerElem.parentNode.removeChild(innerElem);
     }
     function doTest() {
-      while (tick()) { }
-      testPair('block', 'inline');
+      //while (tick()) { }
+      for (var inner of displays) {
+        testPair('table', inner);
+      }
+      //testPair('block', 'inline');
       SimpleTest.executeSoon(SimpleTest.finish);
     }
   </script>
 </head>
 <body onload="doTest()">
   <div id="holder">
   </div>
 </body>
diff --git a/layout/tables/BasicTableLayoutStrategy.cpp b/layout/tables/BasicTableLayoutStrategy.cpp
--- a/layout/tables/BasicTableLayoutStrategy.cpp
+++ b/layout/tables/BasicTableLayoutStrategy.cpp
@@ -444,16 +444,19 @@ BasicTableLayoutStrategy::ComputeIntrins
     ComputeColumnIntrinsicISizes(aRenderingContext);
 
     nsTableCellMap *cellMap = mTableFrame->GetCellMap();
     nscoord min = 0, pref = 0, max_small_pct_pref = 0, nonpct_pref_total = 0;
     float pct_total = 0.0f; // always from 0.0f - 1.0f
     int32_t colCount = cellMap->GetColCount();
     // add a total of (colcount + 1) lots of cellSpacingX for columns where a
     // cell originates
+    if (mTableFrame->StyleDisplay()->IsContainLayout()) {
+        colCount = 0;
+    }
     nscoord add = mTableFrame->GetColSpacing(colCount);
 
     for (int32_t col = 0; col < colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame->GetColFrame(col);
         if (!colFrame) {
             NS_ERROR("column frames out of sync with cell map");
             continue;
         }
diff --git a/layout/tables/FixedTableLayoutStrategy.cpp b/layout/tables/FixedTableLayoutStrategy.cpp
--- a/layout/tables/FixedTableLayoutStrategy.cpp
+++ b/layout/tables/FixedTableLayoutStrategy.cpp
@@ -29,16 +29,19 @@ FixedTableLayoutStrategy::~FixedTableLay
 
 /* virtual */ nscoord
 FixedTableLayoutStrategy::GetMinISize(nsRenderingContext* aRenderingContext)
 {
   DISPLAY_MIN_WIDTH(mTableFrame, mMinISize);
   if (mMinISize != NS_INTRINSIC_WIDTH_UNKNOWN) {
     return mMinISize;
   }
+  if (mTableFrame->StyleDisplay()->IsContainLayout()) {
+    return (mMinISize = 0);
+  }
 
   // It's theoretically possible to do something much better here that
   // depends only on the columns and the first row (where we look at
   // intrinsic inline sizes inside the first row and then reverse the
   // algorithm to find the narrowest inline size that would hold all of
   // those intrinsic inline sizes), but it wouldn't be compatible with
   // other browsers, or with the use of GetMinISize by
   // nsTableFrame::ComputeSize to determine the inline size of a fixed
diff --git a/layout/tables/nsTableCellFrame.cpp b/layout/tables/nsTableCellFrame.cpp
--- a/layout/tables/nsTableCellFrame.cpp
+++ b/layout/tables/nsTableCellFrame.cpp
@@ -980,37 +980,41 @@ nsTableCellFrame::Reflow(nsPresContext* 
   // see testcase "emptyCells.html"
   nsIFrame* prevInFlow = GetPrevInFlow();
   bool isEmpty;
   if (prevInFlow) {
     isEmpty = static_cast<nsTableCellFrame*>(prevInFlow)->GetContentEmpty();
   } else {
     isEmpty = !CellHasVisibleContent(kidSize.Height(), tableFrame, firstKid);
   }
+  // TODO kzentner: Is this necessary?
+  if (StyleDisplay()->IsContainLayout()) {
+    isEmpty = true;
+  }
   SetContentEmpty(isEmpty);
 
   // Place the child
   FinishReflowChild(firstKid, aPresContext, kidSize, &kidReflowState,
                     wm, kidOrigin, containerWidth, 0);
 
   nsTableFrame::InvalidateTableFrame(firstKid, origRect, origVisualOverflow,
                                      firstReflow);
 
   // first, compute the bsize which can be set w/o being restricted by
   // available bsize
   LogicalSize cellSize(wm);
-  cellSize.BSize(wm) = kidSize.BSize(wm);
+  if (!StyleDisplay()->IsContainLayout()) {
+    cellSize.BSize(wm) = kidSize.BSize(wm);
+    cellSize.ISize(wm) = kidSize.ISize(wm);
+  }
 
   if (NS_UNCONSTRAINEDSIZE != cellSize.BSize(wm)) {
     cellSize.BSize(wm) += borderPadding.BStartEnd(wm);
   }
-
-  // next determine the cell's isize
-  cellSize.ISize(wm) = kidSize.ISize(wm);      // at this point, we've factored in the cell's style attributes
-
+  
   // factor in border and padding
   if (NS_UNCONSTRAINEDSIZE != cellSize.ISize(wm)) {
     cellSize.ISize(wm) += borderPadding.IStartEnd(wm);
   }
 
   // set the cell's desired size and max element size
   aDesiredSize.SetSize(wm, cellSize);
 
diff --git a/layout/tables/nsTableFrame.cpp b/layout/tables/nsTableFrame.cpp
--- a/layout/tables/nsTableFrame.cpp
+++ b/layout/tables/nsTableFrame.cpp
@@ -3302,17 +3302,17 @@ nsTableFrame::CalcDesiredBSize(const nsH
     aDesiredSize.BSize(wm) = 0;
     return;
   }
   LogicalMargin borderPadding = GetChildAreaOffset(wm, &aReflowState);
 
   // get the natural bsize based on the last child's (row group) rect
   RowGroupArray rowGroups;
   OrderRowGroups(rowGroups);
-  if (rowGroups.IsEmpty()) {
+  if (StyleDisplay()->IsContainLayout() || rowGroups.IsEmpty()) {
     // tables can be used as rectangular items without content
     nscoord tableSpecifiedBSize = CalcBorderBoxBSize(aReflowState);
     if ((NS_UNCONSTRAINEDSIZE != tableSpecifiedBSize) &&
         (tableSpecifiedBSize > 0) &&
         eCompatibility_NavQuirks != PresContext()->CompatibilityMode()) {
           // empty tables should not have a size in quirks mode
       aDesiredSize.BSize(wm) = tableSpecifiedBSize;
     } else {
@@ -3671,16 +3671,21 @@ nsTableFrame::DistributeBSizeToRows(cons
   ResizeCells(*this);
 }
 
 nscoord
 nsTableFrame::GetColumnISizeFromFirstInFlow(int32_t aColIndex)
 {
   MOZ_ASSERT(this == FirstInFlow());
   nsTableColFrame* colFrame = GetColFrame(aColIndex);
+  // TODO kzentner: Do we need to do this?
+  //nsTableColFrame* colFrame = nullptr;
+  //if (!StyleDisplay()->IsContainLayout()) {
+    //colFrame = GetColFrame(aColIndex);
+  //}
   return colFrame ? colFrame->GetFinalISize() : 0;
 }
 
 nscoord
 nsTableFrame::GetColSpacing()
 {
   if (IsBorderCollapse())
     return 0;
diff --git a/layout/tables/nsTableRowFrame.cpp b/layout/tables/nsTableRowFrame.cpp
--- a/layout/tables/nsTableRowFrame.cpp
+++ b/layout/tables/nsTableRowFrame.cpp
@@ -1115,18 +1115,23 @@ nsTableRowFrame::Reflow(nsPresContext*  
   }
 
   // see if a special bsize reflow needs to occur due to having a pct bsize
   nsTableFrame::CheckRequestSpecialBSizeReflow(aReflowState);
 
   // See if we have a cell with specified/pct bsize
   InitHasCellWithStyleBSize(tableFrame);
 
+  nscoord emptyBSize = aDesiredSize.BSize(wm);
   ReflowChildren(aPresContext, aDesiredSize, aReflowState, *tableFrame, aStatus);
 
+  if (StyleDisplay()->IsContainLayout()) {
+    aDesiredSize.BSize(wm) = emptyBSize;
+  }
+
   if (aPresContext->IsPaginated() && !NS_FRAME_IS_FULLY_COMPLETE(aStatus) &&
       ShouldAvoidBreakInside(aReflowState)) {
     aStatus = NS_INLINE_LINE_BREAK_BEFORE();
   }
 
   // Just set our isize to what was available.
   // The table will calculate the isize and not use our value.
   aDesiredSize.ISize(wm) = aReflowState.AvailableISize();
